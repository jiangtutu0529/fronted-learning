#### 大数据量前端渲染
大数据量前端全部渲染会造成页面卡顿，内存飙升，用户体验差

##### 一、分页
在不要一次性展示全部数据的情况下，可以考虑分页处理，优点时简单易实现好理解
操作：每次从后端请求固定数量的数据，只渲染这固定数量的数据


##### 二、虚拟滚动
必须一次性展示全量数据时，如全量日志查看，并且要保持流畅的体验，可选择虚拟滚动

操作：
1、全量获取后端数据缓存住，但是不全量渲染，
2、计算出可视区域：监听滚动容器的滚动事件，精确计算当前容器应该展示哪些数据
3、渲染可视区域：将计算出的数据创建DOM渲染
4、模拟滚动条：容器的高度是总数据量*每条高度，从而使得滚动条是全量数据视角下的滚动体，可视区域外用空白填充

优点：页面节点少
缺点：实现复杂，需要计算，DOM状态丢失，数据缓存内存需求大

推荐库：
react-window
示例代码：

```
const data = Array.from({ length: 10000 }).map((_, i) => `Item ${i + 1}`);

// 每行渲染组件
const Row = ({ index, style }) => (
  <div style={style}>
    {data[index]}
  </div>
);

const VirtualList = () => (
  <List
    height={400} // 列表容器高度
    itemCount={data.length} // 总条目数
    itemSize={35} // 每项高度
    width={‘100%’} // 容器宽度
  >
    {Row}
  </List>
);
```

##### 三、无限滚动
相比于虚拟滚动，这里数据非一次性全部加载

操作：
1、初始加载一部分数据
2、当滚动到容器底部，触发下一页的加载操作
3、将新数据追加到现有列表末尾

```
const InfiniteScroll(){
  const [data,setData] = useState([])
  const [current,setCurrent] = useState(100)
  const [hasMore,setHasMore] = useState(true)
  const size = 200
  const fetchData = useCallback(()=>{
    const params = {
      page:current
      size:200
    }
    const newData = await fetch(params)
    if(data.length<size){
      setHasMore(false)
    }else{
      setHasMore(true)
    }
    setData([...data,newData])
  },[current])
  const handleMore = ()=>{
    setCurrent(current+100)
  }
  useEffect(()=>{
    fetchData()
  },[fetchData])
  return <div>
  <div>
  {data.map(item=>{
    return <span>{item}</span>
  })}
  </div>
  <button onClick={handleMore}>加载更多</button>
  </div>
}
```

##### 自定义hooks版本无限滚动
```
// useInfiniteScroll.js
import { useState, useEffect, useCallback } from 'react';

export const useInfiniteScroll = (fetchData, totalItems = 10000) => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [hasMore, setHasMore] = useState(true);
  const [page, setPage] = useState(1);
  const [error, setError] = useState(null);

  const loadData = useCallback(async () => {
    if (loading || !hasMore) return;
    
    setLoading(true);
    setError(null);
    
    try {
      const newData = await fetchData(page);
      
      if (newData.length === 0) {
        setHasMore(false);
        return;
      }
      
      setData(prev => [...prev, ...newData]);
      setPage(p => p + 1);
      
      if (data.length + newData.length >= totalItems) {
        setHasMore(false);
      }
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [page, loading, hasMore, data.length, totalItems, fetchData]);

  useEffect(() => {
    loadData();
  }, []);

  return {
    data,
    loading,
    hasMore,
    error,
    loadMore: loadData
  };
};
```

##### 四、时间分片
适用setTimeout，setInterval或requestAnimationFrame将大量DOM的插入分成多个小人物，在浏览器的多帧完成

```
function chunkRender(data, callback) {
  let index = 0;
  const chunkSize = 100; // 每批渲染100条
  
  function doChunk() {
    const chunk = data.slice(index, index + chunkSize);
    // ... 将 chunk 渲染到 DOM ...
    index += chunkSize;
    
    if (index < data.length) {
      // 使用 setTimeout 将控制权交还给浏览器，再继续渲染下一批
      setTimeout(doChunk, 0);
    } else {
      callback?.(); // 全部渲染完成
    }
  }
  
  doChunk();
}
```