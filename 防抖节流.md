#### 防抖
在事件触发一次后，延迟一段时间再执行回调函数，如果在这个时间再触发，重新计时
适用表单验证，提交按钮，搜索框，输入框

##### 一个带取消的防抖实现
```
function debounce(fn,time){
  let timer 
  const debounceFn = (...args)=>{
    if(timer){
      clearTimeout(timer)
    }
    timer = setTimeout(()=>{fn.apply(this,args)},time)
  }
  debounceFn.cancel = ()=>{
    clearTimeout(timer)
  }
  return debounceFn
}
```

##### 一个第一次立即执行的防抖函数
```
function debounceFirst(fn,time){
  let timer
  return function FirstDebounce(...args){
    const callNow = !timer
    clearTimeout(timer)
    timer = setTimeout(()=>{
      timer = null
      if(!callNow){
        fn.apply(this,args)
      }
    },time)
    if(callNow){
      fn.apply(this,args)
    }
  }
}
```

#### 节流
在一段时间内，事件的多次触发，只执行一次
滚动加载，按钮点击，鼠标移动
```
//时间戳版节流
function throttle(fn,time){
  let timer
  let last = 0
  const throttleFn = (...args){
    const now = Date.now()
    if(now-last>time){
      last = now
      fn.apply(this,args)
    }
  }
  return throttleFn
}
```

##### 一个第一次立即执行的节流函数
```
function immediateThrottle(func, limit) {
    let lastCall = 0;
    let immediateCall = true;
    
    return function(...args) {
        const now = Date.now();
        
        if (immediateCall || now - lastCall >= limit) {
            immediateCall = false;
            lastCall = now;
            return func.apply(this, args);
        }
    };
}
```

##### 无限滚动
```
class InfiniteScroll {
    constructor() {
        this.checkScroll = this.throttle(this.loadMore, 200);
        window.addEventListener('scroll', () => this.checkScroll());
    }
    
    loadMore() {
        const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
        if (scrollTop + clientHeight >= scrollHeight - 100) {
            this.fetchNextPage();
        }
    }
    
    throttle(func, limit) {
        let inThrottle;
        return function(...args) {
            if (!inThrottle) {
                func.apply(this, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        };
    }
}
```

##### 自定义防抖hook
```
import { useRef, useCallback } from 'react';

// 自定义防抖 Hook
function useDebounce(callback, delay) {
  // 使用 useRef 来存储定时器 ID
  // useRef 的值在组件整个生命周期内保持不变，且不会触发重渲染
  const timeoutRef = useRef(null);

  // 使用 useCallback 来记忆化防抖函数，避免每次渲染都创建新函数
  const debouncedCallback = useCallback((...args) => {
    // 如果已经有正在等待的定时器，则清除它
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }

    // 设置新的定时器
    timeoutRef.current = setTimeout(() => {
      callback(...args);
    }, delay);
  }, [callback, delay]); // 依赖项：当 callback 或 delay 改变时，重新创建防抖函数

  return debouncedCallback;
}
```