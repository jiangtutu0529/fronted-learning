### 页面性能优化

https://godbasin.github.io/front-end-playground/

#### 1、useMemo,useCallback,memo等改善性能的hooks

#### 2、轻量，原子化的store管理模式
zustand
```
import { create } from 'zustand'
import { labelsCfgApi } from '@/api/app'
import { isArray } from 'lodash'

interface ITreeItem {
  labelsName: string
  labelsId: number
  value: string
  label: string
}
interface UIState {
  labelsList: ITreeItem[]
  getLabelsList: () => Promise<void>
}

export const useLabels = create<UIState>((set, get) => ({
  labelsList: [],
  async getLabelsList() {
    if (get().labelsList.length) return
    try {
      const res = (await labelsCfgApi()) as ITreeItem[]
      set({
        labelsList: isArray(res)
          ? res.map((it) => ({
              ...it,
              value: `${it.labelsId}`,
              label: it.labelsName,
            }))
          : [],
      })
    } catch (error) {
      set({ labelsList: [] })
    }
  },
}))

```
#### 3、性能查看工具
React Developer Tools
PerformanceObserver 

#### 4、长任务监控
```
const onPerformancePlugin = (options: PerformancePluginOptions = {}) => {
  const { minDuration = 1000, scope = 'performance_longtask' } = options
  let observer: PerformanceObserver
  // 全局监听日志处理
  const onPerformanceObserve = () => {
    const perf_observer: PerformanceObserverCallback = (list) => {
      const entries = list.getEntriesByType('longtask')
      if (entries?.[0]?.duration >= minDuration) {
        const message = entries[0].toJSON()
        if (message?.attribution)
          message.attribution = map(message.attribution, (item) => item.toJSON())
        baseInfo({
          type: TLogType.warn,
          scope,
        }, message)
      }
    }
    observer = new PerformanceObserver(perf_observer)
    observer.observe({ entryTypes: ['longtask'] })
  }

  return {
    name: 'on-long-task-plugin',
    onMount: () => {
      onPerformanceObserve()
    },
    onUnmounted: () => {
      observer.disconnect()
    }
  }
}

export default onPerformancePlugin
```
使用时，loadPlugun
```
 loadPlugin(
    onPerformancePlugin({
      minDuration: 200,
    })
  )
```
#### 5、useSelector自定义hooks
重写shallowEqual函数，对于复杂数据类型对比做逻辑
```
import { TypedUseSelectorHook, useDispatch as useReduxDispatch, useSelector as useReduxSelector } from 'react-redux'
import type { RootState, RootDispatch } from '../store'

export function shallowEq(oldValue: unknown, newValue: unknown) {
  if (typeof oldValue === 'object' && typeof newValue === 'object' && oldValue !== null && newValue !== null) {
    if (Object.keys(oldValue).length !== Object.keys(newValue).length) {
      return false
    }
    for (const key in oldValue) {
      const oldValueKey = (oldValue as Record<string, unknown>)[key]
      const newValueKey = (newValue as Record<string, unknown>)[key]
      //判断空数组对比
      if (
        Array.isArray(oldValueKey) &&
        oldValueKey.length === 0 &&
        Array.isArray(newValueKey) &&
        newValueKey.length === 0
      ) {
        continue
      }
      //判断空对象对比
      if (
        typeof oldValueKey === 'object' &&
        typeof newValueKey === 'object' &&
        oldValueKey !== null &&
        newValueKey !== null &&
        Object.keys(oldValueKey).length === 0 &&
        Object.keys(newValueKey).length === 0
      ) {
        continue
      }
      if (oldValueKey !== newValueKey) {
        return false
      }
    }
    return true
  } else {
    return oldValue === newValue
  }
}
// 在整个应用程序中使用，而不是简单的 `useDispatch` 和 `useSelector`
export const useDispatch: () => RootDispatch = useReduxDispatch
export const useSelector: TypedUseSelectorHook<RootState> = (v, equalityFn = shallowEq) =>
  useReduxSelector(v, equalityFn as typeof shallowEq)

```
#### 6、组件传值尽量不使用内联函数
#### 7、子组件key值

