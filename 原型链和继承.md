##### apply,bind,call
apply(obj,[])
bind(obj,args1,args2,args3)
call(obj,args1,args2,args3)

##### 手写一个call
```
Function.prototype.myCall = (obj,...args)=>{
  obj = obj?Object(obj):window
  // // 2. 生成唯一属性键，避免覆盖原属性
  const fnKey = Symbol('fnKey');
  obj[fnKey] = this; // this 指向调用 myCall 的函数
  
  // 3. 执行函数并保存结果
  const result = obj[fnKey](...args);
  
  // 4. 清理临时属性
  delete obj[fnKey];
  return result
}
```
##### 手写一个bind
```
```
##### 手写一个apply
```
```

#### 原型对象
原型继承：每个对象都有一个原型对象__proto__,继承属性和方法，如果当前对象查找不到对应的属性，则沿着原型链查找，通过原型链实现对象间的属性和方法的共享。

原型链：基于原型对象的继承，使得构造函数的原型对象链接在一起，称之为原型链
当访问实例的对象以及属性时，按照  实例本身属性或方法->通过__proto__查找构造函数的属性或方法->递归向上查找->null
原型对象继承：

```


```
##### 寄生组合继承：
```
function inherit(Child, Parent) {
    // 创建父类原型的副本，不调用父类构造函数
    const prototype = Object.create(Parent.prototype);
    
    // 修复constructor指向
    prototype.constructor = Child;
    
    // 设置子类原型
    Child.prototype = prototype;
}

// 使用示例
function Parent(name) {
    this.name = name;
}

Parent.prototype.sayName = function() {
    console.log(this.name);
};

function Child(name, age) {
    Parent.call(this, name);
    this.age = age;
}

inherit(Child, Parent);

Child.prototype.sayAge = function() {
    console.log(this.age);
};
```

##### 组合继承：构造函数继承+原型继承
```
// 父类
function Animal(name) {
  this.name = name;
}
Animal.prototype.eat = function() {
  console.log(`${this.name}正在吃`);
};
 
// 子类
function Dog(name, breed) {
  Animal.call(this, name); // 继承属性
  this.breed = breed;
}
 
// 继承方法（设置原型链）
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog; // 修复 constructor
 
Dog.prototype.bark = function() {
  console.log(`${this.name}汪汪叫`);
};
 
const dog = new Dog("Buddy", "金毛");
dog.eat();  // "Buddy正在吃"
dog.bark(); // "Buddy汪汪叫"
```

#### Object.prototype.isPrototypeOf()
检查对象是否存在于另一个对象的原型链中。
console.log(Animal.prototype.isPrototypeOf(dog)); // true

#### 手写一个new函数
1、创建一个空对象
2、连接原型，将实例的__proto__指向构造函数的prototype属性
3、修改this指向，将this的指向修改到实例，并执行构建函数
4、返回结果，如果构建函数返回了对象，就返回对象，如果没有返回对象就返回新构建的实例
```
//const A = new Person('name')
function MyNew(Constructor,...args){
 // 1. 创建一个新对象，并继承构造函数的原型
  const obj = Object.create(constructor.prototype);

  // 2. 执行构造函数，并将 this 绑定到新对象
  const result = constructor.apply(obj, args);

  // 3. 如果构造函数返回了一个对象，则返回该对象；否则返回新对象
  if (result !== null && (typeof result === 'object' || typeof result === 'function')) {
    return result;
  }
  return obj;
}
```

#### 手写一个instanceof函数
```
function MyInstanceOf(left,right){
  //如果是基本数据类型，返回false
  if(typeof left !=='object'||left === null){
    return false
  }
  let proto = left.__proto__
  while(proto){
    if(proto === right.prototype) return true
    proto = proto.__proto__
  }
  return false
}
function myInstanceof(instance, constructor) {
    // 基本类型直接返回false
    if (instance === null || typeof instance !== 'object') {
        return false;
    }
    
    let proto = Object.getPrototypeOf(instance);
    
    while (proto !== null) {
        if (proto === constructor.prototype) {
            return true;
        }
        proto = Object.getPrototypeOf(proto);
    }
    
    return false;
}
```



##### 实现一个Object.create()
Object.create()创建一个新对象，并将现有对象作为新对象的原型
核心本质：创建一个空对象，将空对象的__proto__指向传入的新对象
```
Object.myCreate = (proto)=>{
  function F(){

  }
  F.prototype = proto
  let obj =  new F()
  // 如果proto为null，需要特殊处理
  if (proto === null) {
      obj.__proto__ = null;
  }
  return obj
}
```

##### class的super关键字的原理

```
class Parent {
    constructor(name) {
        this.name = name;
    }
    
    sayName() {
        console.log(this.name);
    }
}

class Child extends Parent {
    constructor(name, age) {
        // super相当于：Parent.call(this, name)
        super(name);
        this.age = age;
    }
    
    // 方法中的super
    sayInfo() {
        // 相当于：Parent.prototype.sayName.call(this)
        super.sayName();
        console.log(this.age);
    }
}
```

##### 如何防止原型链污染
修改了原型链，影响所有继承该原型的对象，从而会引发安全漏洞
```
// 污染示例
const obj = {};

// 攻击者控制的输入
const maliciousInput = {
    __proto__: {
        isAdmin: true,
        toString: function() { return "Hacked!"; }
    }
};

// 不安全的对象合并
function unsafeMerge(target, source) {
    for (let key in source) {
        target[key] = source[key]; // 可能污染原型
    }
    return target;
}

const result = unsafeMerge(obj, maliciousInput);

// 污染成功！所有对象都受到影响
console.log({}.isAdmin); // true - 原型被污染！
console.log("test".toString()); // "Hacked!" - 连基本类型都受影响

// 方案1：使用 hasOwnProperty
function safeMerge1(target, source) {
    for (let key in source) {
        if (source.hasOwnProperty(key)) {
            target[key] = source[key];
        }
    }
    return target;
}

// 方案2：使用 Object.hasOwn (ES2022)
function safeMerge2(target, source) {
    for (let key in source) {
        if (Object.hasOwn(source, key)) {
            target[key] = source[key];
        }
    }
    return target;
}

// 方案3：使用 Object.keys
function safeMerge3(target, source) {
    Object.keys(source).forEach(key => {
        target[key] = source[key];
    });
    return target;
}

```