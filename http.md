#### 网络
TCP/IP外层模型
1、物理层： 光纤、网线，特流在物理介质上的传输
2、链路层：同一个局域网内，通过MAC地址，数据帧的传送
3、网络层：数据包的选路和转发，将数据包从源主机送到目标主机，核心是IP地址
4、传输层：TCP,UDP，为进程提供端到端的可靠或者不可靠的服务
5、应用层：Http，HTTPS，为应用程序提供网络服务

数据封装过程：
在浏览器输入网址后：
1、应用层：应用层发出HTTP协议请求报文(GET /HTTP/1.1)
2、传输层：在HTTP报文头部加上TCP头部，包含源端口，目标端口80，形成TCP段
3、网络层：在TCP头部加上IP段，包含源IP,目标IP,形成IP数据包
4、链路层：在IP数据包前后加上帧首，帧尾，形成数据帧
5、物理层：将报文转换成比特流，在物理介质传输


##### HTTP
是一种无状态的，位于应用层的协议，基于请求/响应模型
无状态：不记录任何信息，因此引入了人cookie和session来做状态记录
基于文本：早期HTTP1.X基于文本，效率不高，HTTP2基于二进制流
请求-响应模型：客户端发起请求，服务端响应。

请求报文：
```
GET /index.html HTTP/1.1       // 请求行：方法 + URI + 版本
Host: www.example.com          // 请求头部（键值对）
User-Agent: Mozilla/5.0...
Accept: text/html...
（一个空行）
[请求体]（GET 方法通常没有，POST 方法有）
```

响应报文：
```
HTTP/1.1 200 OK                // 状态行：版本 + 状态码 + 状态短语
Content-Type: text/html        // 响应头部
Content-Length: 1234
（一个空行）
[响应体]（如 HTML 内容）
```


##### HTTP方法
GET:
POST:
PUT:
DELETE:
HEAD:只获取响应头，不获取 body。用于检查资源是否存在等
PATCH:对资源进行部分更新

##### HTTP状态码：
1XX:请求已被接收，正在处理
2XX:请求成功
3XX:请求转移
301：永久重定向
302：重定向
304：走缓存
4XX：客户端错误
400:Bad Request 请求语法错误
401：需要身份认证
403:服务器理解请求但是不执行，无权限
404：找不到
5XX:
500：服务端内部错误
502：网关服务器无响应
503：服务不可用


##### HTTP协议演进
HTTP1.0：每个请求都是一个单独的链接
HTTP1.1:
  持久连接：一个TCP连接可以发送多个请求/响应
  管道化：允许客户端可以在同一个连接上连续发送多个请求而不用等待响应，但是存在队头阻塞问题
  主机头：支持虚拟主机
HTTP2:
  二进制分帧：将报文分成二进制帧，提高传输速度
  多路复用：在一个TCP连接上并行交错的发送多个请求/响应，彻底解决HTTP1.0对头阻塞
  头部压缩：使用HPACk压缩头部，减少开销
  服务器推送：服务器可以主动向客户端推送
HTTP3:
  将底层传输协议从TCP改成UDP
  解决了TCP的对头阻塞
  建立连接更快
HTTPS:
  HTTP+SSL/TLS,在TCP和HTTP之间增加安全层SSL
  加密：防止内容被窃听
  完整性校验：防止内容篡改
  身份认证：保证网站真实性
  工作原理：使用非对称加密交换对称加密的密钥，之后使用对称加密进行通信

##### Cookies和Session的区别
Cookies存储在客户端，Session存储在服务端
Session更安全，因为敏感信息存在服务端

##### Cookie
Cookies是服务器给浏览器发送，并在浏览器存储起来，下次发送请求携带此数据，用来管理用户状态。
用途：管理会话状态(用户登录状态，购物车内容，游戏分数)、个性化设置(语言偏好，主题选择)、行为追踪(记录分析用户行为)
原理：基于HTTP的无状态，用请求头和响应头来管理
Cookie属性：
Name和Value:键值对
Domain和path:定义了Cookie的作用域，指定哪些域名和路径下携带cookie
Expires和Max-age:定义过期时间，
HttpOnly:设置为true时，cookie无法通过js的document API获取到,防止xss攻击
Secure：设置为true时，Cookies只会在HTTPS协议中发送
SameSite:控制跨站请求是否携带，防止CSRF攻击
  Strict:禁止跨站携带
  Lax:允许部分安全跨站请求携带
  None:允许跨站携带

##### Session
在服务端存储用户相关状态信息，将敏感歇息存储在服务端，只给客户端一个唯一SessionID凭证
1、客户端请求​​：用户首次访问网站。
2、​​创建 Session​​：服务器为该用户创建一个唯一的 Session ID，并在服务器端（内存、数据库、缓存如 Redis）开辟一块存储空间（Session 文件或对象）。
3、​​返回 Session ID​​：服务器在 HTTP 响应中，通过 Set-Cookie头将这个 Session ID 返回给浏览器。这个 Cookie 通常名为 JSESSIONID(Java) 或 PHPSESSID(PHP) 等。
HTTP/1.1 200 OK
Set-Cookie: JSESSIONID=abcDeF123456789; Path=/; HttpOnly
4、​​客户端存储 Session ID​​：浏览器保存这个包含 Session ID 的 Cookie。
5、​​后续请求​​：浏览器下次请求时，会自动带上这个包含 Session ID 的 Cookie。
GET /profile HTTP/1.1
Host: www.example.com
Cookie: JSESSIONID=abcDeF123456789
6、​​服务器识别用户​​：服务器收到请求后，解析出 Session ID，然后用这个 ID 去服务器的 Session 存储中查找对应的用户数据。找到后，请求处理逻辑就知道当前用户是谁以及其相关状态

##### 如何防止 Session 被劫持？
​​回答思路​​：Session 劫持即攻击者获取了用户的 Session ID 后，冒充用户。
1、​​核心是保护 Session ID 的安全​​。
2、​​设置 Cookie 属性​​：
HttpOnly：防止 XSS 攻击窃取 Cookie。
Secure：保证 Session ID 只在 HTTPS 加密连接中传输，防止网络监听。
SameSite=Strict/Lax：有效防范 CSRF 攻击。
3、​​服务器端增强​​：
​​用户登录后重置 Session ID​​。
​​绑定用户信息​​：在 Session 中存储用户 IP 地址、User-Agent 等指纹信息，每次请求时进行校验，如果变化则要求重新登录。
​​设置合理的 Session 过期时间​​。

##### Cookie 有哪些安全隐患？如何防范？
​​回答思路​​：
​​XSS（跨站脚本）攻击​​：窃取 Cookie。防范：设置 HttpOnly属性。
​​CSRF（跨站请求伪造）攻击​​：利用用户的登录状态发起恶意请求。防范：使用 SameSiteCookie 属性；添加 CSRF Token 进行验证。
​​网络监听​​：在 HTTP 下传输 Cookie 可能被截获。防范：全程使用 HTTPS，并为敏感 Cookie 设置 Secure属性。
​​信息泄露​​：Cookie 中不应存储敏感信息（如密码）

##### HTTP2如何解决HTTP1.1的对头阻塞
​​HTTP/1.1 的队头阻塞​​：在同一个 TCP 连接中，如果前一个请求的响应没有返回，后面的请求就会被阻塞，即使后面的请求先处理完。
​​HTTP/2 的解决方案​​：引入了二进制分帧层。每个请求/响应被分成多个带有唯一 Stream ID 的帧。这些帧在连接上交错发送，接收方根据 Stream ID 重新组装。这样，即使一个流中的帧丢失或延迟，也不会影响其他流的传输

##### HTTPS 的握手过程（SSL/TLS 握手）是怎样的？​​
​​ClientHello​​：客户端发送支持的 TLS 版本、加密套件列表、一个随机数。
​​ServerHello​​：服务器选择 TLS 版本和加密套件，并发送自己的证书和一个随机数。
​​密钥交换​​：客户端验证证书，用证书公钥加密一个预主密钥发送给服务器。
​​生成会话密钥​​：双方用预主密钥和两个随机数，独立计算出相同的对称会话密钥。
​​加密通信​​：后续使用该会话密钥进行对称加密通信。  

##### 什么是跨域问题（CORS）？如何解决？​​
​​原因​​：浏览器的同源策略限制了脚本内发起的跨源 HTTP 请求。
​​解决方案​​：
​​JSONP​​：利用 <script>标签无跨域限制的特性（只支持 GET）。
​​CORS​​：W3C 标准，服务器端设置 Access-Control-Allow-Origin等响应头来允许跨域。
​​代理​​：在开发阶段，使用 webpack-dev-server 等工具代理请求；在生产环境，用 Nginx 反向代理。

##### ​​什么是 DNS？它的解析过程是怎样的？​​
​​DNS​​：域名系统，将域名转换为 IP 地址。
​​解析过程​​：浏览器缓存 -> 操作系统缓存（hosts文件） -> 本地 DNS 服务器 -> 根域名服务器 -> 顶级域服务器（.com） -> 权威域名服务器（example.com） -> 一步步返回 IP 地址


##### 三次握手

在理解握手和挥手之前，必须记住 TCP 的三个核心特点：
1、​​面向连接​​：通信双方在传输数据前，必须首先建立一条可靠的连接。
2、​​可靠传输​​：通过确认机制、重传机制、序列号等保证数据不丢失、不重复、不乱序。
3、​全双工​​：建立连接后，双方都能同时向对方发送和接收数据。
​​三次握手​​就是为了​​建立一条全双工的可靠连接​​。
​​四次挥手​​就是为了​​安全地关闭这条全双工连接

1. 第一次握手（SYN=1, seq=x）​​：
​​客户端发送​​：一个 TCP 报文段。
​​设置标志位​​：将 SYN(Synchronize Sequence Numbers) 标志位设为 1，表示这是一个连接请求报文。
​​生成序列号​​：随机选择一个初始序列号 seq = x。这个序列号用于跟踪后续的数据传输。
​​客户端状态​​：从 CLOSED进入 SYN-SENT（同步已发送）状态。

2. 二次握手（SYN=1, ACK=1, seq=y, ack=x+1）​​：
​​服务器发送​​：一个 TCP 报文段作为应答。
​​设置标志位​​：将 SYN和 ACK(Acknowledgment) 标志位都设为 1。SYN=1表示这也是一个同步报文；ACK=1表示确认号字段有效。
​​生成序列号​​：随机选择自己的初始序列号 seq = y。
​​设置确认号​​：ack = x + 1。这表示“我收到了你的序列号为 x的 SYN 报文，我期望你下一次从 x+1开始发送数据”。
​​服务器状态​​：从 LISTEN进入 SYN-RCVD（同步已收到）状态。

3. 第三次握手（ACK=1, seq=x+1, ack=y+1）​​：
​​客户端发送​​：一个 TCP 报文段。
​​设置标志位​​：将 ACK标志位设为 1。
​​设置序列号​​：seq = x + 1。因为第一次握手消耗了一个序列号 x，所以这次从 x+1开始。
​​设置确认号​​：ack = y + 1。这表示“我收到了你的序列号为 y的 SYN 报文，我期望你下一次从 y+1开始发送数据”。
​​客户端状态​​：进入 ESTABLISHED（连接已建立）状态。
​​服务器状态​​：收到这个 ACK 后，也进入 ESTABLISHED状态。

##### 为什么是三次握手？
​​核心原因：为了防止已失效的连接请求报文突然传送到服务器，导致错误。​​
​​场景模拟（“已失效的请求”）​​：
1、客户端发送了一个连接请求报文 A，但由于网络拥堵，长时间滞留在了网络中。
2、客户端超时后重传了请求报文 B，并与服务器通过“三次握手”正常建立了连接，传输数据后关闭了连接。
3、此时，那个失效的请求报文 A 终于到达了服务器。服务器会认为这是一个新的连接请求。
​​如果是“两次握手”​​：服务器收到 A 后，会立即回复确认并进入 ESTABLISHED状态，开始等待客户端发送数据。但客户端并没有真正想建立连接（请求已失效），会忽略服务器的确认。这将导致服务器空等，浪费了服务器资源。
​​
4、“三次握手”如何解决​​：在第 3 步，客户端需要再次发送确认。对于那个失效的报文 A，客户端不会发出第三次握手确认，服务器收不到确认，就不会建立连接，从而避免了资源浪费。
​​5、 总结​​：三次握手是保证可靠性和最少次数的​​理论最小值​​。两次不安全，四次多余。

##### 四次挥手
双方都可以关闭，假设客户端发起关闭
1. 第一次挥手（FIN=1, seq=u）​​：
​​客户端发送​​：一个 TCP 报文段。
​​设置标志位​​：将 FIN(Finish) 标志位设为 1，表示客户端数据已发送完毕，要求释放连接。
​​客户端状态​​：从 ESTABLISHED进入 FIN-WAIT-1（终止等待1）状态。

2. ​​第二次挥手（ACK=1, seq=v, ack=u+1）​​：
​​服务器发送​​：一个 TCP 报文段作为应答。
​​设置标志位​​：将 ACK标志位设为 1。
​​设置确认号​​：ack = u + 1。这表示“我收到了你的 FIN 报文”。
​​服务器状态​​：从 ESTABLISHED进入 CLOSE-WAIT（关闭等待）状态。
​​此时状态​​：TCP 连接处于​​半关闭状态​​。即客户端已经没有数据要发送了，但服务器可能还有数据要发送给客户端，客户端也需要接收。
​​客户端状态​​：收到这个 ACK 后，从 FIN-WAIT-1进入 FIN-WAIT-2（终止等待2）状态，等待服务器发送 FIN 报文。

3. 第三次挥手（FIN=1, ACK=1, seq=w, ack=u+1）​​：
​​服务器发送​​：当服务器也数据发送完毕后，它会发送一个 FIN 报文。
​​设置标志位​​：将 FIN和 ACK标志位都设为 1。
​​服务器状态​​：从 CLOSE-WAIT进入 LAST-ACK（最后确认）状态，等待客户端的最终确认。

4. 第四次挥手（ACK=1, seq=u+1, ack=w+1）​​：
​​客户端发送​​：一个 TCP 报文段作为应答。
​​设置标志位​​：将 ACK标志位设为 1。
​​设置确认号​​：ack = w + 1。
​​客户端状态​​：从 FIN-WAIT-2进入 TIME-WAIT（时间等待）状态。​​此时客户端不会直接进入 CLOSED，而是需要等待 2MSL（两倍的最大报文段生存时间）时长后，才进入 CLOSED状态。​​
​​服务器状态​​：收到这个 ACK 后，服务器立即进入 CLOSED状态。

##### 为什么是四次挥手
核心原因：TCP 是全双工的，每个方向必须单独进行关闭。​​
​​详细解释​​：当客户端发送 FIN 时，只表示客户端没有数据要发送了，但还可以接收数据。服务器收到 FIN 后，先回复一个 ACK，表示“我知道你要关闭了”。但此时服务器可能还有数据要发送给客户端，所以不能立即发送 FIN。等到服务器也数据发送完毕后，才发送自己的 FIN 报文。因此，ACK 和 FIN 通常是分开发送的，这就比握手多了一次。

##### 为什么客户端需要 TIME-WAIT 状态？等待 2MSL 是为什么？
这也是一个必问题。
​​可靠地终止连接​​：第四次挥手的 ACK 报文有可能丢失。如果客户端发完 ACK 后直接关闭，而服务器没有收到这个 ACK，服务器会超时重传第三次挥手的 FIN 报文。此时客户端已经关闭，无法响应，服务器会不断重试，最终产生错误。等待 2MSL 可以确保如果 ACK 丢失，客户端有足够的时间收到重传的 FIN 报文并重发 ACK。
​​让旧连接的报文在网络中消逝​​：2MSL 的时间足以保证本次连接所产生的所有报文都从网络中消失。这样，下一个新的连接就不会收到旧的、迟到的报文，避免了数据混乱。
​​MSL​​ 是 Maximum Segment Lifetime，即报文最大生存时间，是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。一般建议值为 2 分钟，但实际应用中常用 30 秒或 1 分钟。


##### HTTP2的多路复用原理以及解决了什么问题

HTTP1.1瓶颈：
1、队头阻塞
在同一个 TCP 连接上，虽然可以发送多个请求，但这些请求必须是串行的。也就是说，客户端必须等到前一个请求的响应收到之后，才能发送下一个请求。
这就好比一条单车道，如果第一辆车（请求）开得慢或者抛锚了（比如某个资源处理时间很长），后面的所有车（请求）都得等着，即使它们能开得很快。这就是“队头阻塞”。
2、创建大量连接的overhead
为了规避队头阻塞，浏览器通常会为同一个域名打开多个 TCP 连接（通常是 6-8 个），来同时发送请求。
但每个 TCP 连接的建立和维护都需要成本（TCP 三次握手、TLS 握手、慢启动等）。同时打开太多连接也会占用服务器和客户端的大量资源。


HTTP2多路复用
在单个、持久的 TCP 连接上，同时进行多个请求和响应。这些请求和响应之间互不干扰。
1. 二进制分帧
   这是 HTTP/2 性能提升的基础。HTTP/1.1 是以纯文本（字符串）的形式传输数据，而 HTTP/2 将传输的消息分割成更小的帧，并采用二进制格式进行编码。
    帧：HTTP/2 通信的最小单位。每个帧都有一个帧头，其中最重要的字段是流标识符，它标明了这个帧属于哪个“流”。
    消息：一个完整的请求或响应，由一个或多个帧组成（例如 HEADERS 帧和 DATA 帧）
2. 流
    流是存在于连接中的一个虚拟通道。每个请求/响应交互都被分配一个唯一的流 ID。
    一个流承载着一系列双向的帧：从客户端到服务器的请求帧，以及从服务器返回给客户端的响应帧。
    多个流可以同时在同一 TCP 连接上交错地发送它们的帧。
3. 多路复用过程
    I、浏览器与服务器建立一个 TCP 连接。
    II、浏览器需要请求多个资源（如 page.html, style.css, app.js）。
    III、HTTP/2 为每个请求创建一个新的“流”，并分配一个唯一的流 ID（如 1, 3, 5...）。
    IV、这些请求被分解成 HEADERS 帧和 DATA 帧。所有流的帧被混合在一起，通过同一个 TCP 连接发送到服务器。
        发送顺序可能是：流1的HEADERS帧-> 流3的HEADERS帧-> 流1的DATA帧-> 流5的HEADERS帧...
    V、服务器收到这些交织在一起的帧后，会根据帧头中的流 ID将它们重新组装成完整的请求。
    VI、服务器处理这些请求，生成响应。同样，响应也被分解成帧（如 HEADERS 帧和 DATA 帧）。
    VII、服务器将这些属于不同流的响应帧也混合在一起，通过同一个 TCP 连接发送回浏览器。
    VIII、发送顺序可能是：流3的HEADERS帧-> 流1的HEADERS帧-> 流3的DATA帧-> 流1的DATA帧...
    VIIII、浏览器根据流 ID 将收到的帧分类，并重新组装成完整的响应，交给对应的请求

优势：
  1、彻底解决了 HTTP 层的队头阻塞：一个请求的缓慢不会阻塞其他请求。慢的资源可以慢慢传输，快的资源可以先用上。
  2、只需一个 TCP 连接：极大地减少了连接建立和维护的开销，降低了服务器和客户端的负载。
  3、更高效的网络利用率：一个饱和的 TCP 连接比多个未饱和的连接能更好地利用网络带宽。
  4、原生支持请求优先级：HTTP/2 允许给流设置优先级，让浏览器可以告诉服务器“先加载重要的资源（如CSS、JS），再加载图片”。

  注意：
  HTTP/2 解决了应用层（HTTP）的队头阻塞，但底层依赖的 TCP 协议本身也存在队头阻塞问题。如果单个 TCP 包在传输过程中丢失，TCP 协议会要求重传这个丢失的包，导致所有流（即使它们的包已经正确到达）都必须等待这个丢失的包重传成功。这是 HTTP/2 的一个潜在瓶颈

  而这正是 HTTP/3 和 QUIC 协议要解决的核心问题。HTTP/3 将传输层协议从 TCP 改为基于 UDP 的 QUIC。QUIC 在传输层也实现了类似“流”的多路复用，将数据包丢失的影响隔离在单个流内，从而彻底解决了队头阻塞问题。

##### TCP如何保证可靠
  1、三次握手-建立可靠连接
  2、序列号和确认应答
  3、超时重传
  4、数据校验和
  5、流量控制
  6、拥塞控制
  7、四次挥手


##### Cookie有哪些属性，属性什么作用
1、Max-age和Expires
  Expires指定明确的过期时间
  Max-age指定以秒为单位的有效期
  如果两个都没设置，以当前会话关闭失效，会话cookie
  如果两个都设置了，max-age优先级更高
  如果设置了过去的时间，立即删除
2、Domain-作用域
  指定哪些主机可以接受这个cookie，如果不设置，默认是当前文档的主机，不包含子域名，且cookie不会发送给子域名
  示例1：当前网站是 www.example.com
  不设置 Domain：Cookie 只会在访问 www.example.com时发送。
  设置 Domain=example.com：Cookie 会在访问 example.com及其所有子域名（如 www.example.com、api.example.com、shop.example.com）时发送。

  示例2：无法设置 Domain=.com或 Domain=other-site.com，这是出于安全考虑，防止其他网站访问你的 Cookie。
  作用：控制 Cookie 在域名级别的共享范围
3、Path- 作用域（哪些路径可以访问）
  指定 URL 路径，只有该路径及其子路径下的请求才能携带此 Cookie。
  示例：设置 Path=/admin
    以下 URL 会发送 Cookie：https://www.example.com/admin，https://www.example.com/admin/settings
    以下 URL 不会发送 Cookie：https://www.example.com/，https://www.example.com/user
  如果不设置，默认为当前文档的路径。通常设置为 Path=/，表示该域名下的所有路径都可以访问。
    作用：将 Cookie 限制在网站的特定区域，提高安全性和组织性。
4、secure-安全传输
  标记为 Secure的 Cookie 只能通过 HTTPS协议加密传输。如果请求是 HTTP 协议，浏览器不会发送此 Cookie。
  示例：Secure（这是一个标志，没有值）
  作用：防止 Cookie 在明文传输过程中被窃取。对于存储会话 ID 等敏感信息的 Cookie，必须设置此属性
5、HttpOnly-防止客户端脚本访问
  标记为 HttpOnly的 Cookie 无法通过 JavaScript 的 document.cookieAPI 访问。
  示例：HttpOnly
  作用：这是非常重要的安全措施，可以有效缓解跨站脚本攻击（XSS）。攻击者即使注入了恶意脚本，也无法窃取标记为 HttpOnly的 Cookie（如用户的会话 ID）
6、SameSite- 控制跨站请求是否发送 Cookie
  这是现代浏览器中一个非常重要的安全属性，用于控制第三方上下文（如从其他网站链接过来或提交表单）发起的请求是否携带 Cookie。它有三个值：
  SameSite=Strict（严格模式）
    作用：完全禁止在跨站请求中发送此 Cookie。即，只有当前页面的 URL 与请求目标一致时才会携带 Cookie。
    场景：非常敏感的操作，如银行转账。用户从百度搜索结果点击链接进入你的银行网站，不会携带登录 Cookie，需要重新登录。
  SameSite=Lax（宽松模式，现代浏览器的默认值）
    作用：在大多数跨站请求（如通过 <a>链接导航）中不发送 Cookie，但在一些安全的顶级导航（如 GET 请求）中会发送。
    场景：这是平衡安全与用户体验的最佳实践。用户从邮件或论坛点击链接进入你的网站，可以保持登录状态；但来自其他网站的跨站 POST 表单提交或 <img>请求不会携带 Cookie。
  SameSite=None
    作用：允许在跨站请求中发送 Cookie。但必须同时设置 Secure属性（即需要 HTTPS）。
    场景：用于需要跨站共享登录状态的场景，例如在第三方网站使用嵌入式组件（如“分享”按钮）、iframe 嵌入或跨站 API 调用。 