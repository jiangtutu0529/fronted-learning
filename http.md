#### 网络
TCP/IP外层模型
1、物理层： 光纤、网线，特流在物理介质上的传输
2、链路层：同一个局域网内，通过MAC地址，数据帧的传送
3、网络层：数据包的选路和转发，将数据包从源主机送到目标主机，核心是IP地址
4、传输层：TCP,UDP，为进程提供端到端的可靠或者不可靠的服务
5、应用层：Http，HTTPS，为应用程序提供网络服务

数据封装过程：
在浏览器输入网址后：
1、应用层：应用层发出HTTP协议请求报文(GET /HTTP/1.1)
2、传输层：在HTTP报文头部加上TCP头部，包含源端口，目标端口80，形成TCP段
3、网络层：在TCP头部加上IP段，包含源IP,目标IP,形成IP数据包
4、链路层：在IP数据包前后加上帧首，帧尾，形成数据帧
5、物理层：将报文转换成比特流，在物理介质传输


##### HTTP
是一种无状态的，位于应用层的协议，基于请求/响应模型
无状态：不记录任何信息，因此引入了人cookie和session来做状态记录
基于文本：早期HTTP1.X基于文本，效率不高，HTTP2基于二进制流
请求-响应模型：客户端发起请求，服务端响应。

请求报文：
```
GET /index.html HTTP/1.1       // 请求行：方法 + URI + 版本
Host: www.example.com          // 请求头部（键值对）
User-Agent: Mozilla/5.0...
Accept: text/html...
（一个空行）
[请求体]（GET 方法通常没有，POST 方法有）
```

响应报文：
```
HTTP/1.1 200 OK                // 状态行：版本 + 状态码 + 状态短语
Content-Type: text/html        // 响应头部
Content-Length: 1234
（一个空行）
[响应体]（如 HTML 内容）
```


##### HTTP方法
GET:
POST:
PUT:
DELETE:
HEAD:只获取响应头，不获取 body。用于检查资源是否存在等
PATCH:对资源进行部分更新

##### HTTP状态码：
1XX:请求已被接收，正在处理
2XX:请求成功
3XX:请求转移
301：永久重定向
302：重定向
304：走缓存
4XX：客户端错误
400:Bad Request 请求语法错误
401：需要身份认证
403:服务器理解请求但是不执行，无权限
404：找不到
5XX:
500：服务端内部错误
502：网关服务器无响应
503：服务不可用


##### HTTP协议演进
HTTP1.0：每个请求都是一个单独的链接
HTTP1.1:
  持久连接：一个TCP连接可以发送多个请求/响应
  管道化：允许客户端可以在同一个连接上连续发送多个请求而不用等待响应，但是存在队头阻塞问题
  主机头：支持虚拟主机
HTTP2:
  二进制分帧：将报文分成二进制帧，提高传输速度
  多路复用：在一个TCP连接上并行交错的发送多个请求/响应，彻底解决HTTP1.0对头阻塞
  头部压缩：使用HPACk压缩头部，减少开销
  服务器推送：服务器可以主动向客户端推送
HTTP3:
  将底层传输协议从TCP改成UDP
  解决了TCP的对头阻塞
  建立连接更快
HTTPS:
  HTTP+SSL/TLS,在TCP和HTTP之间增加安全层SSL
  加密：防止内容被窃听
  完整性校验：防止内容篡改
  身份认证：保证网站真实性
  工作原理：使用非对称加密交换对称加密的密钥，之后使用对称加密进行通信

##### Cookies和Session的区别
Cookies存储在客户端，Session存储在服务端
Session更安全，因为敏感信息存在服务端

##### Cookie
Cookies是服务器给浏览器发送，并在浏览器存储起来，下次发送请求携带此数据，用来管理用户状态。
用途：管理会话状态(用户登录状态，购物车内容，游戏分数)、个性化设置(语言偏好，主题选择)、行为追踪(记录分析用户行为)
原理：基于HTTP的无状态，用请求头和响应头来管理
Cookie属性：
Name和Value:键值对
Domain和path:定义了Cookie的作用域，指定哪些域名和路径下携带cookie
Expires和Max-age:定义过期时间，
HttpOnly:设置为true时，cookie无法通过js的document API获取到,防止xss攻击
Secure：设置为true时，Cookies只会在HTTPS协议中发送
SameSite:控制跨站请求是否携带，防止CSRF攻击
  Strict:禁止跨站携带
  Lax:允许部分安全跨站请求携带
  None:允许跨站携带

##### Session
在服务端存储用户相关状态信息，将敏感歇息存储在服务端，只给客户端一个唯一SessionID凭证
1、客户端请求​​：用户首次访问网站。
2、​​创建 Session​​：服务器为该用户创建一个唯一的 Session ID，并在服务器端（内存、数据库、缓存如 Redis）开辟一块存储空间（Session 文件或对象）。
3、​​返回 Session ID​​：服务器在 HTTP 响应中，通过 Set-Cookie头将这个 Session ID 返回给浏览器。这个 Cookie 通常名为 JSESSIONID(Java) 或 PHPSESSID(PHP) 等。
HTTP/1.1 200 OK
Set-Cookie: JSESSIONID=abcDeF123456789; Path=/; HttpOnly
4、​​客户端存储 Session ID​​：浏览器保存这个包含 Session ID 的 Cookie。
5、​​后续请求​​：浏览器下次请求时，会自动带上这个包含 Session ID 的 Cookie。
GET /profile HTTP/1.1
Host: www.example.com
Cookie: JSESSIONID=abcDeF123456789
6、​​服务器识别用户​​：服务器收到请求后，解析出 Session ID，然后用这个 ID 去服务器的 Session 存储中查找对应的用户数据。找到后，请求处理逻辑就知道当前用户是谁以及其相关状态

##### 如何防止 Session 被劫持？
​​回答思路​​：Session 劫持即攻击者获取了用户的 Session ID 后，冒充用户。
1、​​核心是保护 Session ID 的安全​​。
2、​​设置 Cookie 属性​​：
HttpOnly：防止 XSS 攻击窃取 Cookie。
Secure：保证 Session ID 只在 HTTPS 加密连接中传输，防止网络监听。
SameSite=Strict/Lax：有效防范 CSRF 攻击。
3、​​服务器端增强​​：
​​用户登录后重置 Session ID​​。
​​绑定用户信息​​：在 Session 中存储用户 IP 地址、User-Agent 等指纹信息，每次请求时进行校验，如果变化则要求重新登录。
​​设置合理的 Session 过期时间​​。

##### Cookie 有哪些安全隐患？如何防范？
​​回答思路​​：
​​XSS（跨站脚本）攻击​​：窃取 Cookie。防范：设置 HttpOnly属性。
​​CSRF（跨站请求伪造）攻击​​：利用用户的登录状态发起恶意请求。防范：使用 SameSiteCookie 属性；添加 CSRF Token 进行验证。
​​网络监听​​：在 HTTP 下传输 Cookie 可能被截获。防范：全程使用 HTTPS，并为敏感 Cookie 设置 Secure属性。
​​信息泄露​​：Cookie 中不应存储敏感信息（如密码）

##### HTTP2如何解决HTTP1.1的对头阻塞
​​HTTP/1.1 的队头阻塞​​：在同一个 TCP 连接中，如果前一个请求的响应没有返回，后面的请求就会被阻塞，即使后面的请求先处理完。
​​HTTP/2 的解决方案​​：引入了二进制分帧层。每个请求/响应被分成多个带有唯一 Stream ID 的帧。这些帧在连接上交错发送，接收方根据 Stream ID 重新组装。这样，即使一个流中的帧丢失或延迟，也不会影响其他流的传输

##### HTTPS 的握手过程（SSL/TLS 握手）是怎样的？​​
​​ClientHello​​：客户端发送支持的 TLS 版本、加密套件列表、一个随机数。
​​ServerHello​​：服务器选择 TLS 版本和加密套件，并发送自己的证书和一个随机数。
​​密钥交换​​：客户端验证证书，用证书公钥加密一个预主密钥发送给服务器。
​​生成会话密钥​​：双方用预主密钥和两个随机数，独立计算出相同的对称会话密钥。
​​加密通信​​：后续使用该会话密钥进行对称加密通信。  

##### 什么是跨域问题（CORS）？如何解决？​​
​​原因​​：浏览器的同源策略限制了脚本内发起的跨源 HTTP 请求。
​​解决方案​​：
​​JSONP​​：利用 <script>标签无跨域限制的特性（只支持 GET）。
​​CORS​​：W3C 标准，服务器端设置 Access-Control-Allow-Origin等响应头来允许跨域。
​​代理​​：在开发阶段，使用 webpack-dev-server 等工具代理请求；在生产环境，用 Nginx 反向代理。

##### ​​什么是 DNS？它的解析过程是怎样的？​​
​​DNS​​：域名系统，将域名转换为 IP 地址。
​​解析过程​​：浏览器缓存 -> 操作系统缓存（hosts文件） -> 本地 DNS 服务器 -> 根域名服务器 -> 顶级域服务器（.com） -> 权威域名服务器（example.com） -> 一步步返回 IP 地址


##### 三次握手

在理解握手和挥手之前，必须记住 TCP 的三个核心特点：
1、​​面向连接​​：通信双方在传输数据前，必须首先建立一条可靠的连接。
2、​​可靠传输​​：通过确认机制、重传机制、序列号等保证数据不丢失、不重复、不乱序。
3、​全双工​​：建立连接后，双方都能同时向对方发送和接收数据。
​​三次握手​​就是为了​​建立一条全双工的可靠连接​​。
​​四次挥手​​就是为了​​安全地关闭这条全双工连接

1. 第一次握手（SYN=1, seq=x）​​：
​​客户端发送​​：一个 TCP 报文段。
​​设置标志位​​：将 SYN(Synchronize Sequence Numbers) 标志位设为 1，表示这是一个连接请求报文。
​​生成序列号​​：随机选择一个初始序列号 seq = x。这个序列号用于跟踪后续的数据传输。
​​客户端状态​​：从 CLOSED进入 SYN-SENT（同步已发送）状态。

2. 二次握手（SYN=1, ACK=1, seq=y, ack=x+1）​​：
​​服务器发送​​：一个 TCP 报文段作为应答。
​​设置标志位​​：将 SYN和 ACK(Acknowledgment) 标志位都设为 1。SYN=1表示这也是一个同步报文；ACK=1表示确认号字段有效。
​​生成序列号​​：随机选择自己的初始序列号 seq = y。
​​设置确认号​​：ack = x + 1。这表示“我收到了你的序列号为 x的 SYN 报文，我期望你下一次从 x+1开始发送数据”。
​​服务器状态​​：从 LISTEN进入 SYN-RCVD（同步已收到）状态。

3. 第三次握手（ACK=1, seq=x+1, ack=y+1）​​：
​​客户端发送​​：一个 TCP 报文段。
​​设置标志位​​：将 ACK标志位设为 1。
​​设置序列号​​：seq = x + 1。因为第一次握手消耗了一个序列号 x，所以这次从 x+1开始。
​​设置确认号​​：ack = y + 1。这表示“我收到了你的序列号为 y的 SYN 报文，我期望你下一次从 y+1开始发送数据”。
​​客户端状态​​：进入 ESTABLISHED（连接已建立）状态。
​​服务器状态​​：收到这个 ACK 后，也进入 ESTABLISHED状态。

##### 为什么是三次握手？
​​核心原因：为了防止已失效的连接请求报文突然传送到服务器，导致错误。​​
​​场景模拟（“已失效的请求”）​​：
1、客户端发送了一个连接请求报文 A，但由于网络拥堵，长时间滞留在了网络中。
2、客户端超时后重传了请求报文 B，并与服务器通过“三次握手”正常建立了连接，传输数据后关闭了连接。
3、此时，那个失效的请求报文 A 终于到达了服务器。服务器会认为这是一个新的连接请求。
​​如果是“两次握手”​​：服务器收到 A 后，会立即回复确认并进入 ESTABLISHED状态，开始等待客户端发送数据。但客户端并没有真正想建立连接（请求已失效），会忽略服务器的确认。这将导致服务器空等，浪费了服务器资源。
​​
4、“三次握手”如何解决​​：在第 3 步，客户端需要再次发送确认。对于那个失效的报文 A，客户端不会发出第三次握手确认，服务器收不到确认，就不会建立连接，从而避免了资源浪费。
​​5、 总结​​：三次握手是保证可靠性和最少次数的​​理论最小值​​。两次不安全，四次多余。

##### 四次挥手
双方都可以关闭，假设客户端发起关闭
1. 第一次挥手（FIN=1, seq=u）​​：
​​客户端发送​​：一个 TCP 报文段。
​​设置标志位​​：将 FIN(Finish) 标志位设为 1，表示客户端数据已发送完毕，要求释放连接。
​​客户端状态​​：从 ESTABLISHED进入 FIN-WAIT-1（终止等待1）状态。

2. ​​第二次挥手（ACK=1, seq=v, ack=u+1）​​：
​​服务器发送​​：一个 TCP 报文段作为应答。
​​设置标志位​​：将 ACK标志位设为 1。
​​设置确认号​​：ack = u + 1。这表示“我收到了你的 FIN 报文”。
​​服务器状态​​：从 ESTABLISHED进入 CLOSE-WAIT（关闭等待）状态。
​​此时状态​​：TCP 连接处于​​半关闭状态​​。即客户端已经没有数据要发送了，但服务器可能还有数据要发送给客户端，客户端也需要接收。
​​客户端状态​​：收到这个 ACK 后，从 FIN-WAIT-1进入 FIN-WAIT-2（终止等待2）状态，等待服务器发送 FIN 报文。

3. 第三次挥手（FIN=1, ACK=1, seq=w, ack=u+1）​​：
​​服务器发送​​：当服务器也数据发送完毕后，它会发送一个 FIN 报文。
​​设置标志位​​：将 FIN和 ACK标志位都设为 1。
​​服务器状态​​：从 CLOSE-WAIT进入 LAST-ACK（最后确认）状态，等待客户端的最终确认。

4. 第四次挥手（ACK=1, seq=u+1, ack=w+1）​​：
​​客户端发送​​：一个 TCP 报文段作为应答。
​​设置标志位​​：将 ACK标志位设为 1。
​​设置确认号​​：ack = w + 1。
​​客户端状态​​：从 FIN-WAIT-2进入 TIME-WAIT（时间等待）状态。​​此时客户端不会直接进入 CLOSED，而是需要等待 2MSL（两倍的最大报文段生存时间）时长后，才进入 CLOSED状态。​​
​​服务器状态​​：收到这个 ACK 后，服务器立即进入 CLOSED状态。

##### 为什么是四次挥手
核心原因：TCP 是全双工的，每个方向必须单独进行关闭。​​
​​详细解释​​：当客户端发送 FIN 时，只表示客户端没有数据要发送了，但还可以接收数据。服务器收到 FIN 后，先回复一个 ACK，表示“我知道你要关闭了”。但此时服务器可能还有数据要发送给客户端，所以不能立即发送 FIN。等到服务器也数据发送完毕后，才发送自己的 FIN 报文。因此，ACK 和 FIN 通常是分开发送的，这就比握手多了一次。

##### 为什么客户端需要 TIME-WAIT 状态？等待 2MSL 是为什么？
这也是一个必问题。
​​可靠地终止连接​​：第四次挥手的 ACK 报文有可能丢失。如果客户端发完 ACK 后直接关闭，而服务器没有收到这个 ACK，服务器会超时重传第三次挥手的 FIN 报文。此时客户端已经关闭，无法响应，服务器会不断重试，最终产生错误。等待 2MSL 可以确保如果 ACK 丢失，客户端有足够的时间收到重传的 FIN 报文并重发 ACK。
​​让旧连接的报文在网络中消逝​​：2MSL 的时间足以保证本次连接所产生的所有报文都从网络中消失。这样，下一个新的连接就不会收到旧的、迟到的报文，避免了数据混乱。
​​MSL​​ 是 Maximum Segment Lifetime，即报文最大生存时间，是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。一般建议值为 2 分钟，但实际应用中常用 30 秒或 1 分钟。