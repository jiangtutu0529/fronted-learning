```
class EventBus {
  constructor() {
    this.events = {} // {[event: string], Function[]}
  }

  subscribe(event, callback) {
    if (!this.events[event]) {
      this.events[event] = []
    }
    this.events[event].push(callback)
  }

  publish(event, data) {
    const targetEvent = this.events[event]
    if (!targetEvent) {
      throw new Error(`没有匹配的${event}`)
    }
    for (let item of targetEvent) {
      data ? item(data) : item()
    }
  }

  unSubscribe(event) {
    const { [event]: targetEvent, ...rest } = this.events
    this.events = rest
  }

  // 只订阅一次
  once(eventName, callback) {
    const onceCallback = (...args) => {
      callback(...args)
      this.unSubscribe(eventName, onceCallback)
    }
    this.subscribe(eventName, onceCallback)
  }
}

const eventBus = new EventBus()

eventBus.subscribe('click', () => {
  console.log('订阅了click1')
})
eventBus.subscribe('change', () => {
  console.log('订阅了change')
})

eventBus.publish('click')
eventBus.publish('click')
console.log('event: ', eventBus)
eventBus.unSubscribe('click')
console.log('event: ', eventBus)

eventBus.once('input', () => {
  console.log('订阅了input')
})

eventBus.publish('input')

const p = { name: 'leoochen', age: 18 }
const { name, ...rest } = p

console.log(rest, 'rest')
```

##### 观察者模式与发布订阅模式的区别
观察者模式
```
class Subject {
  constructor(){
    this.observers = []
  }
  add(observer){
    this.observers.push(observer)
  }
  notice(message){
    this.observers.forEach(item=>item.update(message))
  }
}
class Observers {
  constructor(){

  }
  update(message){
    console.log(message)
  }
}
const observer = new Observers()
const subject = new Subject()
subject.add(observer)
subject.notice('1111)
```

发布订阅模式
```
class Publish {
  constructor(){
    this.events = {}
  }
  on(eventName,callback){
    if(!this.events[eventName]){
      this.events[eventName] = []
    }
    this.events[eventName].push(callback)
  }
  emit(eventName,data){
    if(this.events[eventName]){
      this.events[eventName].forEach(callback=>callback(data))
    }
  }
}
const event = new Publish()
event.emit('message','hello')
event.on('message',(data)=>{
  console.log(data)
})

```
区别：
观察者：观察者和目标直接关联，直接调用观察者方法
发布-订阅：通过事件中心解耦，通过事件通道传递