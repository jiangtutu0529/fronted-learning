## 前端灰度
由于团队业务复杂，多人协同开发，前端现网发布经常出现问题，为维持平台稳定性，设计前端灰度方案
前端灰度基于webpack的模块联邦机制，本质是将各个子应用在打包时带上版本信息，如子应用名称+版本号，版本号可依据打包时间而定，保证唯一性
打包时，每个子应用的入口文件都是main_app.remoteEntry.js，生成的携带版本信息的链接地址为https://yzftest.woa.com/xv-test/html/fonts/main_app-1.1.1757313012492/main_app.remoteEntry.js，每个子应用的版本信息集成在map信息中通过获取版本而挂载在window上面，在代码访问到对应子应用时，通过window挂载记录的文件入口路径获取到子应用


#### 打包时
webpack的ModuleFederationPlugin将各个分包打包成包含root_app.remoteEntry.js的文件夹，文件夹名称是子应用名称+版本信息，内部包含该子应用下的其他的js文件或资源信息
在主包文件夹打包包含登录与首页的静态资源文件
将控制版本信息的内容写入文件all-module-${latestCommitID}.js中，以当前提交commitID为版本号，确保代码变更和版本对应 
在压缩时将all-module-gray.js压缩进分包打包产物里面
将当次灰度版本信息写入文件beta-version.js中，内容包括本次打包部署的灰度文件名称all-module-${latestCommitID},以及发版人，发版参数，发版需求标题等


#### 部署时
将所有的打包产物部署到服务器上
将beta-version.js部署到特定的路径，此路径后端接口可获取到
此时服务器内容包括
beta-versin.js  本次灰度版本信息
main_app-1.1.1757313012492  各个分包文件夹
all-module-1757313012492  当前版本的控制各个分包的版本文件信息
all-module.js 正式环境控制的各个分包的版本信息

#### 灰度前
在另一个灰度配置页面，配置当前版本需要灰度的人名名单

#### 灰度时
已配置灰度人员刷新页面，登录后请求后端接口当前登陆人是否在灰度环境，如果在灰度环境灰度的是哪个版本的控制文件，后端判断是灰度人员，读取beta-version.js读取版本信息返回
前端页面获取到版本控制信息all-module-1757313012492，创建script标签加载对应的版本控制文件
获取到对应的版本控制文件后，将对应的子应用版本信息挂载在window上，在代码运行时访问到对应的子应用从window上加载对应的地址，加载对应的子应用，即可访问灰度内容

未配置灰度的人员，仍然访问正式版的灰度控制文件all-module.js，加载正式环境未灰度的各个版本子应用


##### 灰度验证完成
灰度验证完成后，将灰度版本文件all-module-1757313012492复制给all-module.js，灰度完成

#### 灰度回退
将灰度人员删除名单即可访问正式内容

灰度请求代码
```
  const getGrayVersionApi = useCallback(async () => {
    if (isLogin && !appendedRef.current) {
      let versionRes = 'all-modules'
      let isGrayResult = false
      let src = `${process.env.HTTPS === 'true' ? 'https' : 'http'}://localhost:6001/__configs.js`
      appendedRef.current = true
      if (process.env.NODE_ENV === 'production' || process.env.GRAY === 'true') {
        try {
          const { isGray = false, version = 'all-modules' } = (await getGrayVersion()) as {
            isGray: boolean
            version: string
          }
          versionRes = version
          isGrayResult = isGray
        } catch (error) {
          versionRes = 'all-modules'
          isGrayResult = false
        } finally {
          dispatch.user.updateIsGray(isGrayResult)
          dispatch.user.updateVersion(versionRes)
          src = `${process.env.PUBLIC_URL || ''}/fonts/${versionRes}.js?${Math.random().toString(16).slice(2)}`
        }
      }
      const script = document.createElement('script')
      script.src = src
      document.body.appendChild(script)
      script.addEventListener('load', () => {
        setDone(true)
      })
    }
  }, [isLogin, rtx_name])
```


#### 灰度难点
1、子应用拆分，store的拆分，子应用之间store的通信
子应用拆分后，主应用只保留简单的登录页面store,子应用为按需动态加载，在加载到子应用时，挂载对应的store

主应用store挂载
```
import { init, Plugin } from '@rematch/core'
import createSagaMiddleware from 'redux-saga'
import { reportYZFLog, REPORT_LOG_LEVEL, ErrorMessage } from '@tencent/yzf-common/reportLog'
import listen from '@share/rematchMiddleware/listen'
import i18n from './i18nModel'
import product from './productModel'
import user from './userModel'
import app from './appModel'
import ioa from '@src/models/ioaModel'
import type { BootstrapRootModel } from './bootstrapStoreTypes'
import reduxPersistPlugin from '@pkg/bootstrap/reduxPersistPlugin'

export const sagaMiddleware = createSagaMiddleware({
  onError: (error: Error, errorInfo) => {
    // log('createSagaMiddleware onError', error, errorInfo)
    reportYZFLog('infoAll', {
      level: REPORT_LOG_LEVEL.level5,
      message: '云智服saga执行异常',
      error,
      info: errorInfo,
    } as ErrorMessage)
  },
})
window.__injectReducers = {}

const injectPlugin = {
  onReducer: (reducer: unknown, modelName: string) => {
    if (modelName === 'userChat' && window.__injectReducers['UserChat']) {
      return window.__injectReducers['UserChat']
    }
    if (modelName === 'AIChat' && window.__injectReducers['AIChat']) {
      return window.__injectReducers['AIChat']
    }
    return undefined
  },
}

const bootstrapStore = init({
  models: {
    user,
    i18n,
    product,
    app,
    ioa,
  } as BootstrapRootModel,
  plugins: [listen as Plugin<BootstrapRootModel>, injectPlugin, reduxPersistPlugin as Plugin<BootstrapRootModel>],
  redux: {
    middlewares: [sagaMiddleware],
  },
})

declare global {
  interface Window {
    store: typeof bootstrapStore
    sagaMiddleware: typeof sagaMiddleware
  }
}

// redux 外获取state
window.store = bootstrapStore
window.sagaMiddleware = sagaMiddleware

export default bootstrapStore


```

分子应用store挂载
```
setAutoFreeze(false)

// pushListeners(chatUserSubscriptions)
pushListeners(artificialInfoSubscriptions)
pushListeners(asyncFormUserSubscriptions)
pushListeners(ivrSubscriptions)


export type RootState = RematchRootState<RootModel> & Store
export type RootDispatch = RematchDispatch<RootModel>

interface StoreMap {
  [key: string]: {
    name?: string
    state: unknown
    reducers: unknown
  }
}

const storeMap: StoreMap = {
  business,
  pushSetting,
}
// redux 外获取state
Object.keys(storeMap).forEach((key) => {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  window.store.addModel({ ...storeMap[key], name: storeMap[key]?.name || key })
})

import('./Chat/reducers/userChatModel')
  .then(() => {
    window.__injectReducers['UserChat'] = UserChatModel
    window.store.addModel({
      name: 'userChat',
      state: UserChatModel.getInitialState(),
      reducers: {},
    })
  })
  .catch(console.error)

import('./AIChat/reducers/userChatModel')
  .then(() => {
    window.__injectReducers['AIChat'] = AIChatModel
    window.store.addModel({
      name: 'AIChat',
      state: AIChatModel.getInitialState(),
      reducers: {},
    })
  })
  .catch(console.error)

const persistor = getPersistor()
persistor.flush().finally(() => persistor.persist())

window.store.addModel({
  name: 'editor',
  reducers: editorModel.caseReducers,
  state: editorModel.getInitialState(),
})

window.sagaMiddleware.run(rootSaga)

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
const dispatch = window.store.dispatch as RootDispatch

//挂载登录成功的action
dispatch(loginSuccessAction())
dispatch.appWebsocket.connect('')
dispatch.guide.loadOnceGuide().then().catch(console.error) // 加载用户操作状态
```
核心挂载api为window.store.addModel()
难点：
业务复杂情况下各个store生成方式不一致，addModel()只能挂载常规{ state, reducers, effects }，无法挂载createReducer(),createSlice()生成的store,因此针对这两种创建store的方式做兼容处理

1、针对createSlice()生成的store,通过对应的获取state函数，获取reducers方式获取重新赋值
```
window.store.addModel({
  name: 'editor',
  reducers: editorModel.caseReducers,
  state: editorModel.getInitialState(),
})
```
2、针对createReducer()生成的store，异步导入model，重新复制state,由于无法获取reducers，因此reducers赋值为空
这里采取另外的方式挂载reducers，通过window.__injectReducers['UserChat'] = UserChatModel的方式，将reducers赋值给window.__injectReducers['UserChat']，在全局监听到onReducer()时，将window.__injectReducers['UserChat']返回，达到挂载reducers的目的
```
window.__injectReducers = {}

const injectPlugin = {
  onReducer: (reducer: unknown, modelName: string) => {
    if (modelName === 'userChat' && window.__injectReducers['UserChat']) {
      return window.__injectReducers['UserChat']
    }
    if (modelName === 'AIChat' && window.__injectReducers['AIChat']) {
      return window.__injectReducers['AIChat']
    }
    return undefined
  },
}
```

```
import('./Chat/reducers/userChatModel')
  .then(() => {
    window.__injectReducers['UserChat'] = UserChatModel
    window.store.addModel({
      name: 'userChat',
      state: UserChatModel.getInitialState(),
      reducers: {},
    })
  })
  .catch(console.error)
```


2、加载时序问题
因为区分了主包加载与分包加载，这里需要确定加载时序问题，如果在加载前需要引入的包没有引入会导致报错
