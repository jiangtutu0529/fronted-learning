##### 日志系统记录哪些数据
##### FPS：
每秒帧数
利用window.requestAnimationFrame计算浏览器空闲计数
```
const onFramesPerSecondPlugin = (options: PerformancePluginOptions) => {
  let count = 0
  let prevTimestamp: number

  let result: number

  function showFPS(fps: number) {
    options?.onFPSChange?.(fps)
  }

  const loop = () => {
    const timestamp = performance.now()

    options?.onFrameRender?.()

    if (prevTimestamp) {
      count++
      // 间隔超过 1s，将之前计算的 count 输出
      if (timestamp - prevTimestamp >= 1000) {
        showFPS(count)
        prevTimestamp = timestamp
        count = 0
      }
    } else {
      prevTimestamp = timestamp
    }
    result = window.requestAnimationFrame(loop)
  }

  return {
    name: 'on-frames-per-second-plugin',
    onMount: () => {
      result = window.requestAnimationFrame(loop)
    },
    onUnmounted: () => {
      window.cancelAnimationFrame(result)
    }
  }
}

export default onFramesPerSecondPlugin
```
##### 长任务:
利用PerformanceObserver进行长任务监控
```
const onPerformancePlugin = (options: PerformancePluginOptions = {}) => {
  const { minDuration = 1000, scope = 'performance_longtask' } = options
  let observer: PerformanceObserver
  // 全局监听日志处理
  const onPerformanceObserve = () => {
    const perf_observer: PerformanceObserverCallback = (list) => {
      const entries = list.getEntriesByType('longtask')
      if (entries?.[0]?.duration >= minDuration) {
        const message = entries[0].toJSON()
        if (message?.attribution)
          message.attribution = map(message.attribution, (item) => item.toJSON())
        baseInfo({
          type: TLogType.warn,
          scope,
        }, message)
      }
    }
    observer = new PerformanceObserver(perf_observer)
    observer.observe({ entryTypes: ['longtask'] })
  }

  return {
    name: 'on-long-task-plugin',
    onMount: () => {
      onPerformanceObserve()
    },
    onUnmounted: () => {
      observer.disconnect()
    }
  }
}

export default onPerformancePlugin

```
##### 监听全局日志
监听window.addEventListener('error', onWindowError)事件，
```
const onGlobalErrorPlugin = () => {
  // 全局监听日志处理
  const onWindowError = (e: WindowEventMap['error']) => {
    let message = e.message
    if ((e.error instanceof Error)) message = `${e.error.message}|${e.error.stack}`

    else if (typeof e.error === 'string') {
      message = e.error
    }

    baseInfo({
      type: TLogType.error,
      scope: 'global_error',
    }, {
      message,
      filename: e.filename
    })

    return true
  }

  return {
    name: 'on-global-error-plugin',
    onMount: () => {
      window.addEventListener('error', onWindowError)
    },
    onUnmounted: () => {
      window.removeEventListener('error', onWindowError)
    }
  }
}

export default onGlobalErrorPlugin

```
##### 如何监控页面错误
```
class ErrorBoundary extends PureComponent<ErrorBoundaryProps> {
  state = {
    error: null,
    info: null,
    refreshCount: 0,
  }

  static getDerivedStateFromError(error: Error) {
    // Update state so the next render will show the fallback UI.
    return { error }
  }

  componentDidCatch(error: Error, info: ErrorInfo) {
    // You can also log the error to an error reporting service
    // logErrorToMyService(error, info);
    console.error('ErrorBoundary.componentDidCatch', error, info, this.props.reportData)

    const reportData = {
      level: this.props.level || REPORT_LOG_LEVEL.level2,
      message: this.props.message || '组件渲染失败',
      error,
      info,
      reportData: null as unknown,
    }

    if (this.props.reportData) {
      reportData.reportData = this.props.reportData
    }

    reportYZFLog('error', reportData)
    this.setState({ error, info, refreshCount: this.state.refreshCount + 1 })
    setTimeout(this.props.onRecordSave, 2000)
  }

  render() {
    if (this.state.error) {
      if (this.props.fallback) return this.props.fallback
      if (this.state.refreshCount > 2)
        return (
          <UIErrorReload>
            <img alt={'page_error'} src={PageErrorSvg as string} />
            <p>
              抱歉，重试无效，请清除浏览器缓存重试
              <Button type={'text'} onClick={() => window.location.reload()}>
                点此刷新
              </Button>
            </p>
          </UIErrorReload>
        )
      // You can render any custom fallback UI
      return (
        <UIErrorReload>
          <img alt={'page_error'} src={PageErrorSvg as string} />
          <span className="__button" onClick={() => this.setState({ error: null })}>
            {`遇到异常啦, 点击重试(${this.state.refreshCount})～`}
          </span>
          重试无效请清除浏览器缓存
        </UIErrorReload>
      )
    }

    return this.props.children
  }
}

```
##### 如何提供错误告警日志
统一接口，错误日志分等级，监控平台设置错误等级预警通知，TAM
##### 如何做接口错误统一管理
使用interceptors的中间件统一处理，在response里面的中间件统一处理
instance.interceptors.response.use(reportLongTime.onFulfilled)
```
const onFulfilled = (response) => {
  const {aegisXhrStartTime, aegisUrl} = (response?.request as { aegisUrl: string; aegisXhrStartTime: number }) || {}
  if (aegisXhrStartTime) {
    const timeInterval = Date.now() - aegisXhrStartTime
    if (timeInterval > TIME_MAX) {
      reportYZFLog('infoAll', {
        level: REPORT_LOG_LEVEL.level4,
        message: `接口响应超过${TIME_MAX}ms`,
        info: {
          aegisXhrStartTime,
          aegisUrl,
          timeInterval,
        },
      } as ErrorMessage)
    }
  }
  return response
};

export const reportLongTime = {onFulfilled}
```
##### 如何监控页面白屏
监控主要文件加载状态
监控主要页面比如根节点是否加载
##### 页面白屏如何排查
chrome工具，检查关键DOM节点，检查关键js加载
##### getDerivedStateFromError 和 componentDidCatch 有什么区别？
答案：
getDerivedStateFromError在渲染阶段调用，用于更新state和渲染降级UI
componentDidCatch在提交阶段调用，用于执行副作用（如错误日志记录）
前者是静态方法，后者是实例方法
前者用于UI恢复，后者用于错误处理逻辑

##### 错误边界可以捕获哪些类型的错误？
答案：
✅ 子组件的渲染错误
✅ 子组件的生命周期方法错误
✅ 子组件的构造函数错误
❌ 事件处理器中的错误
❌ 异步代码错误
❌ 服务端渲染错误
❌ 错误边界自身抛出的错误

##### 为什么 getDerivedStateFromError 必须是静态方法？
答案：
静态方法无法访问 this，确保在错误处理期间不会产生副作用
渲染阶段调用，需要保持纯函数特性
与 React 的并发特性兼容，可以在不同的渲染周期中安全调用