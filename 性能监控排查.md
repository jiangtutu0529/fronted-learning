##### 如何进行性能监控
##### 性能监控指标
##### 如何排查卡顿问题
1. 渲染卡顿
2. js卡顿
   webWorker处理复杂任务
   ```
   // 1. 使用 Web Workers 处理复杂计算
class CalculationWorker {
    constructor() {
        this.worker = new Worker('calculation-worker.js');
    }
    
    heavyCalculation(data) {
        return new Promise((resolve, reject) => {
            this.worker.onmessage = (e) => resolve(e.data);
            this.worker.onerror = reject;
            this.worker.postMessage(data);
        });
    }
}
   ```
3. 网络卡顿
```
class RequestOptimizer {
    constructor() {
        this.pendingRequests = new Map();
        this.cache = new Map();
    }
    
    // 请求去重
    async deduplicatedRequest(url, options = {}) {
        const cacheKey = JSON.stringify({ url, options });
        
        // 如果已有相同请求在进行中，返回该Promise
        if (this.pendingRequests.has(cacheKey)) {
            return this.pendingRequests.get(cacheKey);
        }
        
        const requestPromise = this.makeRequest(url, options);
        this.pendingRequests.set(cacheKey, requestPromise);
        
        try {
            const result = await requestPromise;
            this.cache.set(cacheKey, result);
            return result;
        } finally {
            this.pendingRequests.delete(cacheKey);
        }
    }
    
    // 批量请求
    async batchRequests(requests, batchSize = 5) {
        const results = [];
        
        for (let i = 0; i < requests.length; i += batchSize) {
            const batch = requests.slice(i, i + batchSize);
            const batchPromises = batch.map(req => this.deduplicatedRequest(req.url, req.options));
            
            const batchResults = await Promise.allSettled(batchPromises);
            results.push(...batchResults);
            
            // 批次间延迟，避免同时发起太多请求
            if (i + batchSize < requests.length) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
        }
        
        return results;
    }
}
```
4. 内存卡顿
   监听器未释放
   定时器未释放
   DOM引用未释放
```
 const memory = performance.memory;
            const snapshot = {
                label,
                timestamp: Date.now(),
                usedJSHeapSize: memory.usedJSHeapSize,
                totalJSHeapSize: memory.totalJSHeapSize,
                jsHeapSizeLimit: memory.jsHeapSizeLimit
            };
```
##### 如何监控长任务

```
   if ('PerformanceObserver' in window) {
            const observer = new PerformanceObserver((list) => {
                list.getEntries().forEach((entry) => {
                    if (entry.duration > 50) { // 超过50ms的任务
                        this.longTasks.push(entry);
                        this.reportLongTask(entry);
                    }
                });
            });
            
            observer.observe({ entryTypes: ['longtask'] });
        }
```
##### 如何排查并解决页面重复渲染问题