#### Promise的执行顺序
```
console.log('1');

setTimeout(() => console.log('2'), 0);

Promise.resolve().then(() => console.log('3'));

console.log('4');
```
输出结果1->4->3->2

1和4是同步任务，优先执行
Promise.resolve.then()是微任务
setTimeout是宏任务
事件循环：同步任务->清空微任务栈->执行一个宏任务->清空微任务栈->执行下一个宏任务


#### 任务执行：
##### 1、new一个Promise的过程是同步的，包括.then()注册callback的行为也是同步的，真正异步的是被注册的成功以及失败的回调（它们得等待状态改变，而且不知道什么时候才会改变），且它们都是微任务
```
const P1 = new Promise((resolve, reject) => {
  console.log('new Promise是同步操作')
  resolve(1);
});
setTimeout(() => {
  console.log('我是异步宏任务')
}, 0)
P1.then((e) => {
  console.log('我是异步微任务')
  console.log(e);
})
// new Promise是同步操作
// 我是异步微任务
// 我是异步宏任务

```
##### 2、当存在多个Promise调用需要区分执行顺序时，我们往往以.then()注册callback的顺序来决定执行顺序
```
const P1 = Promise.resolve(1);
const P2 = Promise.resolve(2);
P1.then((e) => {
  console.log('我先注册的，所以先输出1')
  console.log(e);
})
P2.then((e) => {
  console.log('我后注册的，所以我后面输出2')
  console.log(e);
})
// 我先注册的，所以先输出1
// 1
// 我后注册的，所以我后面输出2
// 2

```
##### 3、.then的callback中往往也能再返回一个Promise，这时候就是我们所说的链式调用，而当存在多个链式调用时，我们心里会默认，只要你多.then()一次，你的执行就得往后排一次
```
const P1 = Promise.resolve(1);
const P2 = Promise.resolve(2);
P1.then((e) => {
    console.log(e)
    return Promise.resolve(3)
  })
  .then((e) => console.log(e));
P2.then((e) => {
  console.log(e);
})
// 1
// 2
// 3

```
##### 4、.then()内部返回了一个Promise，那么这个Promise的执行得往后延后两次，而不是一次，这是因为.then()中的Promise在改变状态到执行，底层会创建2次微任务，导致它的执行往后推两次
```
Promise.resolve()
  .then(() => {
    console.log(0);
    // then内部返回promise，默认理解成延迟2次后执行
    return Promise.resolve(4);
  }).then((res) => {
    console.log(res)
  })

Promise.resolve()
  .then(() => {
    console.log(1);
  }).then(() => {
    console.log(2);
  }).then(() => {
    console.log(3);
  })
// 0 1 2 3 4

```
##### 5、Promise.then的有无返回值的区别
返回的是Promise，那么下一个.then肯定得等待这个Promise状态发生改变才能执行,但是还有返回不是Promise
```
Promise.resolve(1)
  .then(
    (e) => {
      console.log(1)
      return 2;
    }
  ).then((e) => {
    console.log(e)
    return 3;
  })
  .then((e) => {
    console.log(e)
  });
// 1 2 3

```
类似于,
```
Promise.resolve(1)
  .then(
    (e) => {
      console.log(1)
      return Promise.resolve(2);
    }
  ).then((e) => {
    console.log(e)
    return Promise.resolve(3);
  })
  .then((e) => {
    console.log(e)
  });

```
当返回一个数字或者字符串，只要不是Promise，它本质上都会被resolve转化成成功的状态，但是return 4和return Promise.resolve(4)相比，后者比前者多创建一次微任务。
无返回值的情况，默认返回undefined
##### 6、当Promise.then()的没有提供callback，或者callback不是一个函数时，Promise会发生值穿透
```
const P1 = Promise.resolve('值穿透');
P1.then((res) => {
  console.log(res); // 值穿透;
});

P1.then()
  .then()
  .then()
  .then((res) => {
    console.log(res); //值穿透
  });

```
第二个执行，我们链式调用了多个.then()并且都没有提供成功或者失败的回调，这种情况就会导致状态和值发生穿透，因此最后一个.then()还是能成功获取到值穿透

##### 7、创建new Promise()是同步任务
```
const p = new Promise((resolve,reject)=>{
  console.log(1)
  console.log(2)
})
p.then(()=>{
  console.log(3)
})
console.log(4)
```
1 2 4
关于3不输出，是因为创建的promise.then是微任务，需要任务执行完成状态改变，但是这里没有完成一直是pending状态，所以不执行输出3

##### 8、执行任务的状态改变
```
const promise1 = new Promise((resolve,reject)=>{
  console.log('promise1')
  resolve('resolve1')
})
const promise2 = promise1.then((res)=>{
  console.log(res)
})
console.log('1',promise1)
console.log('2',promise2)
```
输出结果：
promise1
1 Promise{<resolved>:resolve1}
2 Promise{<pending>:}
resolve1

执行解释：
script是一段宏任务代码，先执行这个宏任务代码
promise1的创建时同步代码，先输出promise1，然后resolve将promise1的状态改变为resolved,并记录结果
promise2的创建是一个微任务，放在微任务队列，并且此时promise2的状态改变为pending状态
执行同步console.log，输出1 Promise{<resolved>:resolve1}
执行同步console.log，输出2 Promise{<pending>:}
宏任务执行完毕，执行微任务队列，执行完微任务，输出resolve1

##### 9、promise.then是等到状态改变才会将结果推入微任务队列中
```
const promise = new Promise((resolve,reject)=>{
  console.log(1)
  setTimeout(()=>{
    console.log('timeStart')
    resolve('success')
    console.log('timeEnd')
  },0)
  console.log(2)
})
promise.then(res=>{
  console.log(res)
})
console.log(4)
```
1 2 4 timeStart timeEnd success
执行：
同步代码顺序执行1 2 4,遇到setTimeout放入宏任务队列，遇到promise.then因为状态是pending,状态还没改变，所以不入微任务队列，此时微任务队列为空，
接着执行宏任务setTimeout，输出timeStart 
遇到resolve('success')，改变pending的状态为resolved，并将结果放到微任务队列，
执行同步代码 输出timeEnd
执行完同步代码，执行微任务，输出success

##### 10、Promise.resolve().then()是微任务
```
Promise.resolve().then(() => {
  console.log('promise1');
  const timer2 = setTimeout(() => {
    console.log('timer2')
  }, 0)
});
const timer1 = setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(() => {
    console.log('promise2')
  })
}, 0)
console.log('start');
```
start promise1 timer1 promise2 timer2


##### 11、throw抛出错误直接rejected
```
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('success')
  }, 1000)
})
const promise2 = promise1.then(() => {
  throw new Error('error!!!')
})
console.log('promise1', promise1)
console.log('promise2', promise2)
setTimeout(() => {
  console.log('promise1', promise1)
  console.log('promise2', promise2)
}, 2000)
```
promise1 pending
promise2 pending
error
promise1 Promise{<resolved>:success}
promise2 Promise{<resolved>:rejected}

##### 12、链式调用
```
Promise.resolve(1)
  .then(res => {
    console.log(res);
    return 2;
  })
  .catch(err => {
    return 3;
  })
  .then(res => {
    console.log(res);
  });
```
1 2
执行：因为第一个.then的返回相当于resolve(2),并没有走catch,所以不会走catch

```
Promise.resolve(1)
  .then(res => {
    console.log(res);
    return Promise.reject(3);
  })
  .catch(err => {
    console.log('ccc')
    return 3;
  })
  .then(res => {
    console.log('aaa')
    console.log(res);
  })
.catch(res=>{
  console.log('bbb')
  console.log(res)
})
```
1 ccc aaa 3

##### 13、返回非Promise值会被包成resolve()
```
Promise.resolve().then(() => {
  return new Error('error!!!')
}).then(res => {
  console.log("then: ", res)
}).catch(err => {
  console.log("catch: ", err)
})
```
“then: ” "Error:error!!!"
执行：
返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的 return new Error("error!!!")也被包裹成了 return Promise.resolve(new Error('error!!!'))，因此它会被then捕获而不是catch

##### 14、死循环
```
const promise = Promise.resolve().then(() => {
  return promise;
})
promise.catch(console.err)
```
 输出结果：

Uncaught (in promise) TypeError: Chaining cycle detected for promise #<Promise>

解释：

.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环

##### 15、process.nextTick是微任务
```console.log('1');
 
setTimeout(function() {
    console.log('2');
    process.nextTick(function() {
        console.log('3');
    })
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})
process.nextTick(function() {
    console.log('6');
})
new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    console.log('8')
})
 
setTimeout(function() {
    console.log('9');
    process.nextTick(function() {
        console.log('10');
    })
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})

```
1 7 6 8 2 4 3 5 9 11 10 12

##### 16、Promise.resolve是同步执行的，.then()方法中的回调函数是异步执行的，.finally()也是异步执行的
```
Promise.resolve('1')
  .then(res => {
    console.log(res)
  })
  .finally(() => {
    console.log('finally')
  })
Promise.resolve('2')
  .finally(() => {
    console.log('finally2')
  	return '我是finally2返回的值'
  })
  .then(res => {
    console.log('finally2后面的then函数', res)
  })
```
1 finally2 finally finally2后面的then函数2

##### 17、Promise.all
```
function runAsync (x) {
    const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
    return p
}
 
Promise.all([runAsync(1), runAsync(2), runAsync(3)]).then(res => console.log(res))
```
1 2 3 [1,2,3]

##### 18、Promise.all的捕获输出
```
function runAsync (x) {
  const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
  return p
}
function runReject (x) {
  const p = new Promise((res, rej) => setTimeout(() => rej(`Error: ${x}`, console.log(x)), 1000 * x))
  return p
}
Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
       .then(res => console.log(res))
       .catch(err => console.log(err))
```
//1s后输出
1
3
//2s后输出
2
Error 2
//4s后输出
4


可以看到，catch捕获到了第一个错误，在这道题目中最先的错误是runReject(2)的结果。如果一组异步操作中有一个异常都不会进入.then()的第一个回调函数参数中，会被.then()的第二个回调函数捕获

##### 19、Promise.race
```
function runAsync (x) {
  const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
  return p
}
Promise.race([runAsync(1), runAsync(2), runAsync(3)])
  .then(res => console.log('result: ', res))
  .catch(err => console.log(err))
```
1
result 1
2
3
可以看到，then只会捕获第一个成功的方法，其他的函数虽然还会继续执行，但是不会被then捕获了。

注意：all和race传入的数组中如果有会抛出异常的一步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但是并不会影响数组中其他的异步任务的执行

##### 20、async的执行
```
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
async1();
console.log('start')
```
async1 start
async2
start
async1 end

1、首先执行函数中的同步代码async1 start，之后遇到了await，它会阻塞async1后面代码的执行，因此会先执行async2中的同步代码saync2，单后跳出async1

2、跳出async1函数之后，执行同步代码start

3、在一轮宏任务全部执行完之后，再来执行await后面的内容async end

可以理解为await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在了Promise.then中

##### 21、多项async的执行
```
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
  setTimeout(() => {
    console.log('timer1')
  }, 0)
}
async function async2() {
  setTimeout(() => {
    console.log('timer2')
  }, 0)
  console.log("async2");
}
async1();
setTimeout(() => {
  console.log('timer3')
}, 0)
console.log("start")
```
 输出结果：

async1 start

async2

start

async1 end

timer2

timer3

timer1

代码解释：

1、首先进入async1，打印async1 start

2、之后遇到async2,进入async2，遇到定时器timer2,加入宏任务队列，之后打印async2

3、由于async2阻塞了后面代码的执行，所以执行后面的定时器timer3，将其加入宏任务队列，之后打印start

4、然后执行async2后面的代码，打印出async1 end，遇到定时器timer1，将其加入宏任务队列

5、最后，宏任务队列有三个任务，先后顺序为timer1，timer3，timer，没有微任务，所以直接所有的宏任务按照先进先出的原则执行

##### 22、async中new Promise
```
async function async1 () {
  console.log('async1 start');
  await new Promise(resolve => {
    console.log('promise1')
  })
  console.log('async1 success');
  return 'async1 end'
}
console.log('srcipt start')
async1().then(res => console.log(res))
console.log('srcipt end')
```
代码输出

script start

async1 start

promise1

script end

代码解释：

在async1中await后面的Promise是没有返回值的，也就是它的状态始终是pending状态，所以在await之后的内容是不会执行的，包括async1后面的.then

##### 23、async中阻塞 new Promise
```
async function async1 () {
  console.log('async1 start');
  await new Promise(resolve => {
    console.log('promise1')
    resolve('promise1 resolve')
  })
  console.log('async1 success');
  return 'async1 end'
}
console.log('srcipt start')
async1().then(res => console.log(res))
console.log('srcipt end')
```
输出结果 

script start

async1 start

promise1

script end

async1 success

async1 end

代码解释：

1、先输出script start

2、执行async1()，输出async1 start，执行Promise里面同步代码 输出promise1，然后执行resolve，await下一行及以后的代码被阻塞

3、继续执行script中同步代码，打印script end

4、宏任务执行完毕，继续执行被await阻塞的代码，输出async1 success

5、最后执行async1().then,输出async1 end

##### 24、async抛出错误后不执行
```
async function async1 () {
  await async2();
  console.log('async1');
  return 'async1 success'
}
async function async2 () {
  return new Promise((resolve, reject) => {
    console.log('async2')
    reject('error')
  })
}
async1().then(res => console.log(res))
```
 输出结果：

async2
Uncaught (in promise) error

可以看出，如果async函数中抛出了错误，就会中止错误结果，不会继续向下执行
##### 25、async抛出错误后继续执行用catch捕获
```
async function async1 () {
  await Promise.reject('error!!!').catch(e => console.log(e))
  console.log('async1');
  return Promise.resolve('async1 success')
}
async1().then(res => console.log(res))
console.log('script start')
```
 输出结果

script start
error!!!
async1
async1 success

如果想要让错误不足之处后面的代码执行，可以使用catch来捕获
##### 26、async和Promise的复杂处理
```
const first = () => (new Promise((resolve, reject) => {
    console.log(3);
    let p = new Promise((resolve, reject) => {
        console.log(7);
        setTimeout(() => {
            console.log(5);
            resolve(6);
            console.log(p)
        }, 0)
        resolve(1);
    });
    resolve(2);
    p.then((arg) => {
        console.log(arg);
    });
}));
first().then((arg) => {
    console.log(arg);
});
console.log(4);
```
输出结果3、7、4、2、1、5、Promise{<resolved>:1}

代码解释：

1、首先会进入Promise，打印出3，之后进入下面的Promise，打印出7

2、遇到了定时器，将其加入宏任务队列

3、执行Promise p中的resolve，状态变为resolved，返回值为1

4、执行Promise first中的resolve，状态变为resolved，返回值为2

5、遇到p.then，将其加入微任务，遇到first().then，将其加入微任务队列

6、执行外面的代码，打印出4

7、这样第一轮宏任务就执行完了，开始执行微任务队列中的任务，先后打印出1和2

8、这样微任务就执行完了，开始执行下一轮宏任务，宏任务队列中有一个定时器，执行它，打印出5，由于执行已经变为resolved状态，所以resolve(6)不会再执行

9、最后console.log(p)打印出Promise{<resolved>:1}

##### 27、asyn 后面的new Promise没有返回值后面的代码不会执行
```
const async1 = async () => {
  console.log('async1');
  setTimeout(() => {
    console.log('timer1')
  }, 2000)
  await new Promise(resolve => {
    console.log('promise1')
  })
  console.log('async1 end')
  return 'async1 success'
} 
console.log('script start');
async1().then(res => console.log(res));
console.log('script end');
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .catch(4)
  .then(res => console.log(res))
setTimeout(() => {
  console.log('timer2')
}, 1000)
```
输出结果：

script start
async1
promise1
script end
1
timer2
timer1

代码解释：

1、首先执行同步带吗，打印出script start；

2 、遇到定时器timer1将其加入宏任务队列；

3 之后是执行Promise，打印出promise1，由于Promise没有返回值，所以后面的代码不会执行；

4 、然后执行同步代码，打印出script end；

5、 继续执行下面的Promise，.then和.catch期望参数是一个函数，这里传入的是一个数字，因此就会发生值渗透，将resolve(1)的值传到最后一个then，直接打印出1；

6、 遇到第二个定时器，将其加入到微任务队列，执行微任务队列，按顺序依次执行两个定时器，但是由于定时器时间的原因，会在两秒后先打印出timer2，在四秒后打印出timer1。