### 浏览器缓存
cache-control：
max-age:缓存时间
no-store:不缓存
no-cache：协商缓存
private：只允许浏览器缓存
public：代理服务器都可以缓存

expreies: 过期时间，时间不一致有问题


缓存过程：
请求时先判断浏览器是否缓存->无缓存以及无缓存字段->请求服务器
判断缓存->有缓存，cache-control:no-store或者max-age过期
|
1、判断上次请求返回是否有Etag，有的话，本次请求携带if-none-match，服务器对比tag内容，有更改返回新的资源，没有更改返回304
2、判断上次请求返回是否有last-modified，有的话，本次请求携带last-modified-since，服务器对比时间，有更改返回新的资源，没更改返回304

缓存资源选择：
# CSS/JS/图片等hash化资源
Cache-Control: public, max-age=31536000, immutable

# HTML页面（经常更新）
Cache-Control: no-cache
# 或
Cache-Control: max-age=0, must-revalidate


频繁变更资源：不缓存


##### webStorage
###### sessionStorage
会话结束，自动清除，单个标签页内有效，通常5-10M,仅当前标签页有效
###### localStorage
永久存储，手动清除，同源窗口共享，通常5-10M,同源的所有页面共享，存储时先序列化存储
###### indexDB
浏览器内置NOSQL数据库
IndexedDB
    ↓
Database (数据库)
    ↓
ObjectStore (对象仓库，类似表)
    ↓
Index (索引，加速查询)
    ↓
Cursor (游标，遍历数据)

操作：
```
function openDatabase() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('MyDatabase', 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    
    // 数据库升级（创建对象仓库）
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      
      // 创建用户对象仓库
      if (!db.objectStoreNames.contains('users')) {
        const userStore = db.createObjectStore('users', { 
          keyPath: 'id', 
          autoIncrement: true 
        });
        
        // 创建索引
        userStore.createIndex('name', 'name', { unique: false });
        userStore.createIndex('email', 'email', { unique: true });
      }
      
      // 创建产品对象仓库
      if (!db.objectStoreNames.contains('products')) {
        const productStore = db.createObjectStore('products', {
          keyPath: 'sku'
        });
        
        productStore.createIndex('category', 'category', { unique: false });
        productStore.createIndex('price', 'price', { unique: false });
      }
    };
  });
}
class IDBManager {
  constructor(dbName, version) {
    this.dbName = dbName;
    this.version = version;
    this.db = null;
  }
  
  // 初始化数据库
  async init() {
    this.db = await this.openDB();
    return this;
  }
  
  openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        this.setupStores(db);
      };
    });
  }
  
  setupStores(db) {
    // 用户表
    if (!db.objectStoreNames.contains('users')) {
      const store = db.createObjectStore('users', { keyPath: 'id' });
      store.createIndex('email', 'email', { unique: true });
      store.createIndex('createdAt', 'createdAt', { unique: false });
    }
  }
  
  // 添加数据
  async add(storeName, data) {
    const transaction = this.db.transaction([storeName], 'readwrite');
    const store = transaction.objectStore(storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.add(data);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  // 获取数据
  async get(storeName, key) {
    const transaction = this.db.transaction([storeName], 'readonly');
    const store = transaction.objectStore(storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.get(key);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  // 更新数据
  async put(storeName, data) {
    const transaction = this.db.transaction([storeName], 'readwrite');
    const store = transaction.objectStore(storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.put(data);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  // 删除数据
  async delete(storeName, key) {
    const transaction = this.db.transaction([storeName], 'readwrite');
    const store = transaction.objectStore(storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.delete(key);
      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
}
```
