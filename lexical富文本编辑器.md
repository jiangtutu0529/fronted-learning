### lexical富文本编辑器
半封装的富文本编辑器，需要自己去组装富文本编辑器功能，适合用来打造自己的个性化的富文本编辑器


##### lexical编辑器底层原理是什么？
Lexical 的核心设计目标是：​​高性能、可扩展、可预测​​.自己完全接管了文档状态的管理和 DOM 的更新.

双状态系统：
  编辑器状态：
    Editor State，这是 Lexical 的​​唯一真相来源​​。它是一个不可变（Immutable）的 JavaScript 对象，以树形结构（Lexical 节点树）描述了编辑器的全部内容、格式、选区等。所有的变更最终都会生成一个新的、不可变的编辑器状态

  DOM状态：
    DOM State​​：这是用户在浏览器中实际看到和交互的视图层。它仅仅是编辑器状态的一个“投影”或“渲染结果”。

单向数据流：
  1、用户输入​​：用户在 contentEditable的 DOM 中进行输入、删除、格式化等操作。
  2、​​监听 DOM 事件​​：Lexical 监听了大量的 DOM 事件（如 input, keydown, click, beforeinput等）。
  3、​​协调器（Reconciler）介入​​：当事件发生时，Lexical 不会直接去修改 DOM。相反，它会​​阻止或劫持​​原生的浏览器行为，然后根据用户的意图，​​生成一个对应的编辑器命令（Command）​​。
  4、​​应用命令，更新状态​​：这个命令会被派发（Dispatch），作用于​​当前的编辑器状态​​，从而生成一个​​新的、不可变的编辑器状态​​。
  5、​​协调器协调更新​​：协调器拿到新旧两个状态，进行 ​​Diff（差异比较）​​，计算出最小化的变更集。
  6、​​更新 DOM​​：协调器根据计算出的变更集，以​​最精确、最高效​​的方式去更新 DOM，使其与新的编辑器状态保持一致。
##### 编辑器是否考虑协同
@lexical/yjs包提供了一个绑定器，可以自动将 Lexical 的更新与 Yjs 的 CRDT 模型同步，Yjs 负责处理所有复杂的冲突解决和操作同步
##### 如何解决页面节点过多的卡顿渲染问题
1、精准的 DOM 更新（颗粒化协调）
  工作原理​​：
    当编辑器状态变更时，协调器会对比新旧两棵节点树。
    它精确地知道​​哪些特定的节点发生了改变​​（文本内容、格式）、哪些节点被添加或删除。
    它​​直接操作 DOM API​​，只更新需要变化的那个或那几个 DOM 元素。
2、可中断的渲染（Concurrent Rendering）
  ​​工作原理​​：
    当有大的状态更新（如粘贴大量内容）时，Lexical 的协调器可以将更新工作分解成多个小块。
    React 的调度器可以​​中断​​协调器的 Diff 和 DOM 更新工作，去优先处理更高优先级的任务（如用户输入、动画），然后再回来继续完成剩余的渲染工作。
3、节点虚拟化（Node Virtualization）
  只渲染可视区域（viewport）内的节点。可视区域之外的节点不被创建对应的 DOM 元素，从而极大减少 DOM 节点数量，提升渲染性能和内存效率。
4、节点类型化与扁平化结构
  Lexical 的节点树设计本身就有利于性能。
  ​   ​类型化节点​​：每个节点类型（ParagraphNode, HeadingNode, ListNode）有明确的语义和渲染逻辑，协调器可以快速判断如何更新。
    ​​避免深层嵌套​​：鼓励相对扁平的节点结构。虽然支持嵌套，但过深的嵌套会影响 Diff 性能。良好的节点设计可以保持结构的相对扁平
5、惰性计算与缓存
  Lexical 在内部大量使用缓存和惰性计算来避免重复工作。
    ​​选区计算​​：选区（Selection）的计算是惰性的，只有在需要时才进行计算。
    ​​节点路径缓存​​：访问节点路径等操作会被缓存，避免重复遍历树结构

6、 批量更新（更新事务）
  将多个连续的操作合并成一个大的更新，从而只触发一次协调和 DOM 更新。

7、选择性监听更新
    不是所有的更新都需要进行复杂的处理。你可以精确控制何时响应更新。
##### 编辑器的selection相关

##### 如何支持自定义插件扩展
```
import { LexicalEditor, LexicalCommand, createCommand } from 'lexical';

// 自定义插件类
class MyCustomPlugin {
  constructor(editor: LexicalEditor) {
    this.editor = editor;
  }
  
  // 必须实现的方法
  initialize(): void {
    // 初始化逻辑
  }
  
  // 清理方法
  destroy(): void {
    // 清理工作
  }
}

// 注册插件
editor.registerPlugin(MyCustomPlugin);
```
