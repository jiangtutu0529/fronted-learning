##### AMD，CMD，Commonjs,ESMoudle
全局污染:作用域隔离
依赖管理:显式声明依赖
代码复用:模块导出导入
可维护性:高内聚、低耦合
```
// 1. 无模块化（全局污染）
var name = 'global';
function foo() {} // 全局函数

// 2. IIFE模式（命名空间）
var module = (function() {
  var privateVar = 'private';
  return { publicApi: function() {} };
})();

// 3. CommonJS（Node.js）
module.exports = { api: function() {} };
const mod = require('./module');

// 4. AMD/CMD（浏览器异步）
define(['dep'], function(dep) { return {}; });

// 5. ES6 Modules（现代标准）
export const api = () => {};
import { api } from './module.js';
```

##### CommonJS和ES Moudle的区别
加载方式：
Commonjs运行时加载，ES6 Moudle编译时加载

输出类型：
Commonjs是值的copy，浅拷贝，ES6Moudle值得引用(实时绑定)

加载时机：
Commonjs是同步加载(阻塞)，ESMoudle是异步加载(非阻塞)

Tree Shaking：
Commonjs不支持，ESMoudle支持

循环依赖：
Commonjs有限支持，ESMoudle较好支持

```
// 🔄 CommonJS：值拷贝
// lib.js
let counter = 0;
module.exports = { counter, increment: () => counter++ };

// main.js  
const { counter, increment } = require('./lib');
console.log(counter); // 0
increment();
console.log(counter); // 0 ❌ 不变（拷贝的值）

// 🔄 ES6 Modules：实时绑定
// lib.js
export let counter = 0;
export function increment() { counter++; }

// main.js
import { counter, increment } from './lib.js';
console.log(counter); // 0
increment();
console.log(counter); // 1 ✅ 实时更新
```

主要区别在于加载时机和值传递方式。CommonJS 是运行时加载，输出值的拷贝，适合服务端同步场景。ES6 Modules 是编译时加载，输出值的实时绑定，支持静态分析优化如 Tree Shaking，更适合现代前端开发


##### 什么是 Tree Shaking？它是如何工作的？
定义：Tree Shaking 是消除死代码（dead code）的优化技术。
工作原理：
静态分析：ES6 Modules 的 import/export是静态的，打包工具可以分析依赖关系
标记未使用代码：识别导出但未被导入的代码
消除死代码：在最终打包产物中移除这些代码


##### 循环依赖
循环依赖可以通过代码重构、使用函数导出或动态导入来解决。ES6 Modules 对循环依赖的支持比 CommonJS 更好，但最好的做法是从设计上避免循环依赖