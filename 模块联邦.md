## 模块联邦
基于webpack5的ModuleFederationPlugin插件实现的微前端架构。
将大型应用拆分成可独立的，业务代码切割明显的分应用，以及一个轻量的，不包含业务，变动变更较少的主服务，由主服务在运行时加载时动态引入分应用，从而动态的加载各项分应用，分应用可独立打包，独立部署，独立更新。
从而在此基础上实现按特定人员的灰度前端应用，实现前端灰度发布。
并且在此基础上优化了前端的构建产物打包速度，优化CI/CD流程，加入灰度策略，配合实现前端灰度发版。

### 模块联邦基本配置与功能
```
    new ModuleFederationPlugin({
      name: 'HOMEAPP',
      filename: 'remoteEntry.js',
      exposes: {
        './List': './src/components/List',
      },
      shared: [
        {
          react: {
            requiredVersion: deps.react,
            singleton: true,
            eager: true,
          },
          'react-dom': {
            requiredVersion: deps['react-dom'],
            singleton: true,
            eager: true,
          },
        },
      ],
    }),
```
1、name表示子应用唯一标识名称
2、filename标识子应用远程入口文件名称
3、exposes标识子应用暴露的组件
4、shared标识子应用共享的依赖，以及版本号，是否单例，是否立即加载

### 模块联邦的实现原理
```
export async function dynamicImport(path: string) {
  const [remoteName, remoteUrl] =
    Object.entries(window.__remotes__ || {}).find(([r]) =>
      path.startsWith(r)
    ) || []

  if (!remoteName) throw new Error(`URL not configured for remote '${path}'.`)
  if (remoteUrl.split('@').length !== 2)
    throw new Error(`URL misconfigured for remote '${path}'`)

  const [moduleName, moduleUrl] = remoteUrl.split('@')

  await __webpack_init_sharing__('default')

  await new Promise<void>((resolve, reject) => {
    const element = document.createElement('script')

    element.src = moduleUrl
    element.type = 'text/javascript'
    element.async = true

    element.onload = () => {
      element.parentElement.removeChild(element)
      resolve()
    }

    element.onerror = (err) => {
      element.parentElement.removeChild(element)
      reject(err)
    }

    document.head.appendChild(element)
  })

  const container = window[moduleName]
  await container.init(__webpack_share_scopes__.default)

  const component = `.${path.replace(remoteName, '')}`
  const factory = await container.get(component)

  return factory()
}

```
在打包时，确定各个子应用的版本信息，将版本信息记录在文件中version.js，打包时控制子应用的名称带上版本信息，通过记录的版本信息生成预加载的各个子应用的入口文件路径，将各个子应用路径信息组装成map信息挂在在window.__all_version_modules__上，这些内容记录在all-module.js中，作为控制版本的主要文件
部署时，将打包完成的各版本子应用发布到服务器上，并且将all-module.js同步发布到服务器上
在页面访问时，页面登录模块个人信息登陆后获取all-module.js文件，文件内容为js代码自执行，会将版本信息挂载到window变量上，在代码里面动态引入时会从window的变量上获取到挂载的路径进行加载
version.js
```
module.exports.APP_VERSIONS = {
  task_app: '1.6.1756177121379',
  push_app: '1.16.1756177121379',
  learning_app: '1.6.1756177121379',
}

```

all-module.js
```
window.__all_version_modules__ = {
  "task_app": [{
    "version": "1.6.1757313012489",
    "url": "/xv-test/html/fonts/task_app-1.6.1757313012489/task_app.remoteEntry.js"
  }],
  "push_app": [{
    "version": "1.16.1757313012489",
    "url": "/xv-test/html/fonts/push_app-1.16.1757313012489/push_app.remoteEntry.js"
  }],
  "main_app": [{
    "version": "1.1.1757313012492",
    "url": "/xv-test/html/fonts/main_app-1.1.1757313012492/main_app.remoteEntry.js"
  }],
};
window.__yzf_loaders_setting__ = [{
  test: '*',
  use: [{
    loader: 'latest'
  }]
}];
```

生成all-module.js
```
createAllModulesContent(mode, path.resolve(__dirname, '../dist/all-modules.js'))
  .then(() => {
    console.log('createAllModulesContent exec success')
  })
  .catch((err) => {
    console.error(err)
    process.exit(1)
  })
```
createAllModulesContent.js
```
const base64UrlPlugin = ({ types: t }) => ({
  visitor: {
    StringLiteral(path) {
      const { value } = path.node
      if (Regex.test(value)) {
        const base64Url = Buffer.from(value).toString('base64')
        console.log('【替换】', value, '=>', base64Url)
        const atobCallExpression = t.callExpression(t.identifier('atob'), [t.stringLiteral(base64Url)])
        path.replaceWith(atobCallExpression)
      }
    },
  },
})
const createAllModulesContent = (mode, filePath) => {
  return new Promise(async (resolve, reject) => {
    const modules = {}
    let env

    if (mode === 'start') env = process.env.ENV
    else {
      env = mode ? require(`@tencent/yzf-config/env/${mode}`) : require(`@tencent/yzf-config/env/production`)
      const parsed = Object.assign({}, env)
      _.forEach(env, (value, key) => {
        parsed[key] = String(value)
      })
      dotenvExpand({
        parsed: parsed,
      })
    }

    // 重新读取以便应用环境变量
    delete require.cache[require.resolve('../coffee/version')]
    const { REMOTE_APPS, EXTRA_MODULES, ALL_MODULE_APPS } = require('../coffee/version')
    const { APP_VERSIONS } = require('../coffee/STATIC_VERSION')

    _.forOwn(APP_VERSIONS, (value, key) => {
      if (!_.isArray(modules[key])) modules[key] = []
      modules[key].push({
        version: value,
        env: ALL_MODULE_APPS[key].env,
        url: process.env.REACT_APP_HTML_PREFIX + `/fonts/${key}-${value}/${key}.remoteEntry.js`,
      })
    })

    // 加载remote apps到all_version_modules
    _.forOwn(REMOTE_APPS, (value, key) => {
      modules[key] = value
    })

    Object.assign(modules, EXTRA_MODULES)

    // 根据环境判断分包是否需要加载
    _.forOwn(modules, (module, key) => {
      modules[key] = module.filter((item) => {
        const env = item.env
        delete item.env
        return !env || env.includes(mode)
      })

      if (modules[key].length === 0) delete modules[key]
    })

    const allModulesTemp = `
      window.__all_version_modules__ = ${JSON.stringify(modules)}

      window.__yzf_loaders_setting__ = [
        {
          test: '*',
          use: [{ loader: 'latest' }],
        },
      ]
    `

    if (!fs.existsSync(path.dirname(filePath))) {
      mkdirSync(path.dirname(filePath))
    }

    console.log(mode, mode.includes('-woa'))
    const result = babel.transformSync(allModulesTemp, {
      plugins: mode.includes('-woa') ? [] : [base64UrlPlugin],
    })

    fs.writeFile(filePath, result.code, (err) => {
      if (err) reject(err)
      console.log(chalk.green(`create ${filePath} success`))
      resolve()
    })
  })
}

exports.createAllModulesContent = createAllModulesContent
```

##### 工作原理
构建时：
```
// Webpack生成的特殊入口文件
// remoteEntry.js 结构：
var app_a = {
  // 模块映射表
  modules: {
    './Button': () => import('./src/components/Button')
  },
  // 模块获取方法
  get: (module) => Promise.resolve(modules[module]())
};
```
运行时：
加载流程
```
应用B加载 → 检测到remote依赖 → 动态加载remoteEntry.js → 
建立模块映射 → 按需加载远程模块 → 模块执行
```

##### 关键技术点
```
异步模块加载
使用 import()动态导入
模块懒加载，减少初始包体积
2. 模块作用域隔离
每个容器的模块有独立作用域
通过全局变量名进行命名空间隔离
3. 版本协商
共享模块的版本冲突解决
支持回退和降级策略
```