## 模块联邦
基于webpack5的ModuleFederationPlugin插件实现的微前端架构。
将大型应用拆分成可独立的，业务代码切割明显的分应用，以及一个轻量的，不包含业务，变动变更较少的主服务，由主服务在运行时加载时动态引入分应用，从而动态的加载各项分应用，分应用可独立打包，独立部署，独立更新。
从而在此基础上实现按特定人员的灰度前端应用，实现前端灰度发布。
并且在此基础上优化了前端的构建产物打包速度，优化CI/CD流程，加入灰度策略，配合实现前端灰度发版。

### 模块联邦基本配置与功能
```
    new ModuleFederationPlugin({
      name: 'HOMEAPP',
      filename: 'remoteEntry.js',
      exposes: {
        './List': './src/components/List',
      },
      shared: [
        {
          react: {
            requiredVersion: deps.react,
            singleton: true,
            eager: true,
          },
          'react-dom': {
            requiredVersion: deps['react-dom'],
            singleton: true,
            eager: true,
          },
        },
      ],
    }),
```
1、name表示子应用唯一标识名称
2、filename标识子应用远程入口文件名称
3、exposes标识子应用暴露的组件
4、shared标识子应用共享的依赖，以及版本号，是否单例，是否立即加载

### 模块联邦的实现原理
```
export async function dynamicImport(path: string) {
  const [remoteName, remoteUrl] =
    Object.entries(window.__remotes__ || {}).find(([r]) =>
      path.startsWith(r)
    ) || []

  if (!remoteName) throw new Error(`URL not configured for remote '${path}'.`)
  if (remoteUrl.split('@').length !== 2)
    throw new Error(`URL misconfigured for remote '${path}'`)

  const [moduleName, moduleUrl] = remoteUrl.split('@')

  await __webpack_init_sharing__('default')

  await new Promise<void>((resolve, reject) => {
    const element = document.createElement('script')

    element.src = moduleUrl
    element.type = 'text/javascript'
    element.async = true

    element.onload = () => {
      element.parentElement.removeChild(element)
      resolve()
    }

    element.onerror = (err) => {
      element.parentElement.removeChild(element)
      reject(err)
    }

    document.head.appendChild(element)
  })

  const container = window[moduleName]
  await container.init(__webpack_share_scopes__.default)

  const component = `.${path.replace(remoteName, '')}`
  const factory = await container.get(component)

  return factory()
}

```
在打包时，确定各个子应用的版本信息，将版本信息记录在文件中version.js，打包时控制子应用的名称带上版本信息，通过记录的版本信息生成预加载的各个子应用的入口文件路径，将各个子应用路径信息组装成map信息挂在在window.__all_version_modules__上，这些内容记录在all-module.js中，作为控制版本的主要文件
部署时，将打包完成的各版本子应用发布到服务器上，并且将all-module.js同步发布到服务器上
在页面访问时，页面登录模块个人信息登陆后获取all-module.js文件，文件内容为js代码自执行，会将版本信息挂载到window变量上，在代码里面动态引入时会从window的变量上获取到挂载的路径进行加载
version.js
```
module.exports.APP_VERSIONS = {
  task_app: '1.6.1756177121379',
  push_app: '1.16.1756177121379',
  learning_app: '1.6.1756177121379',
}

```

all-module.js
```
window.__all_version_modules__ = {
  "task_app": [{
    "version": "1.6.1757313012489",
    "url": "/xv-test/html/fonts/task_app-1.6.1757313012489/task_app.remoteEntry.js"
  }],
  "push_app": [{
    "version": "1.16.1757313012489",
    "url": "/xv-test/html/fonts/push_app-1.16.1757313012489/push_app.remoteEntry.js"
  }],
  "main_app": [{
    "version": "1.1.1757313012492",
    "url": "/xv-test/html/fonts/main_app-1.1.1757313012492/main_app.remoteEntry.js"
  }],
};
window.__yzf_loaders_setting__ = [{
  test: '*',
  use: [{
    loader: 'latest'
  }]
}];
```

生成all-module.js
```
createAllModulesContent(mode, path.resolve(__dirname, '../dist/all-modules.js'))
  .then(() => {
    console.log('createAllModulesContent exec success')
  })
  .catch((err) => {
    console.error(err)
    process.exit(1)
  })
```
createAllModulesContent.js
```
const base64UrlPlugin = ({ types: t }) => ({
  visitor: {
    StringLiteral(path) {
      const { value } = path.node
      if (Regex.test(value)) {
        const base64Url = Buffer.from(value).toString('base64')
        console.log('【替换】', value, '=>', base64Url)
        const atobCallExpression = t.callExpression(t.identifier('atob'), [t.stringLiteral(base64Url)])
        path.replaceWith(atobCallExpression)
      }
    },
  },
})
const createAllModulesContent = (mode, filePath) => {
  return new Promise(async (resolve, reject) => {
    const modules = {}
    let env

    if (mode === 'start') env = process.env.ENV
    else {
      env = mode ? require(`@tencent/yzf-config/env/${mode}`) : require(`@tencent/yzf-config/env/production`)
      const parsed = Object.assign({}, env)
      _.forEach(env, (value, key) => {
        parsed[key] = String(value)
      })
      dotenvExpand({
        parsed: parsed,
      })
    }

    // 重新读取以便应用环境变量
    delete require.cache[require.resolve('../coffee/version')]
    const { REMOTE_APPS, EXTRA_MODULES, ALL_MODULE_APPS } = require('../coffee/version')
    const { APP_VERSIONS } = require('../coffee/STATIC_VERSION')

    _.forOwn(APP_VERSIONS, (value, key) => {
      if (!_.isArray(modules[key])) modules[key] = []
      modules[key].push({
        version: value,
        env: ALL_MODULE_APPS[key].env,
        url: process.env.REACT_APP_HTML_PREFIX + `/fonts/${key}-${value}/${key}.remoteEntry.js`,
      })
    })

    // 加载remote apps到all_version_modules
    _.forOwn(REMOTE_APPS, (value, key) => {
      modules[key] = value
    })

    Object.assign(modules, EXTRA_MODULES)

    // 根据环境判断分包是否需要加载
    _.forOwn(modules, (module, key) => {
      modules[key] = module.filter((item) => {
        const env = item.env
        delete item.env
        return !env || env.includes(mode)
      })

      if (modules[key].length === 0) delete modules[key]
    })

    const allModulesTemp = `
      window.__all_version_modules__ = ${JSON.stringify(modules)}

      window.__yzf_loaders_setting__ = [
        {
          test: '*',
          use: [{ loader: 'latest' }],
        },
      ]
    `

    if (!fs.existsSync(path.dirname(filePath))) {
      mkdirSync(path.dirname(filePath))
    }

    console.log(mode, mode.includes('-woa'))
    const result = babel.transformSync(allModulesTemp, {
      plugins: mode.includes('-woa') ? [] : [base64UrlPlugin],
    })

    fs.writeFile(filePath, result.code, (err) => {
      if (err) reject(err)
      console.log(chalk.green(`create ${filePath} success`))
      resolve()
    })
  })
}

exports.createAllModulesContent = createAllModulesContent
```

##### 工作原理
构建时：
```
// Webpack生成的特殊入口文件
// remoteEntry.js 结构：
var app_a = {
  // 模块映射表
  modules: {
    './Button': () => import('./src/components/Button')
  },
  // 模块获取方法
  get: (module) => Promise.resolve(modules[module]())
};
```
运行时：
加载流程
```
应用B加载 → 检测到remote依赖 → 动态加载remoteEntry.js → 
建立模块映射 → 按需加载远程模块 → 模块执行
```

##### 关键技术点
```
异步模块加载
使用 import()动态导入
模块懒加载，减少初始包体积
2. 模块作用域隔离
每个容器的模块有独立作用域
通过全局变量名进行命名空间隔离
3. 版本协商
共享模块的版本冲突解决
支持回退和降级策略
```


##### 模块联邦的底层原理
传统webpack在构建时将所有依赖打包成一个或者多个bundle，模块联邦实现了‘运行时模块化’，允许一个js程序在运行时动态的加载并执行另一个应用的代码模块。
###### 构建时：
为运行时准备元数据和代码结构，包括remote应用和Host应用
1、remote应用构建过程
负责暴露模块给其他模块应用,生成核心文件remoteEntry.js，
```
// webpack.config.js of Remote
new ModuleFederationPlugin({
  name: 'app_remote', // 全局唯一标识
  filename: 'remoteEntry.js', // 入口清单文件
  exposes: {
    './Button': './src/Button.js', // 暴露模块的映射表
    './Widget': './src/Widget.js'
  },
  shared: ['react', 'react-dom']
})
```
生成remoteEntry.js,内容是模块映射表
```
// remoteEntry.js (简化版)
var moduleMap = {
  // 模块ID与加载函数的映射
  "./Button": () => {
    return Promise.all([/* 依赖检查 */]).then(() => {
      // 返回一个包装过的模块，其__webpack_require__指向Remote自己的模块系统
      return __webpack_require__.e(/*chunkId*/).then(__webpack_require__.bind(__webpack_require__, /*moduleId*/));
    });
  }
};

// 全局注册：将映射表挂载到全局作用域
__webpack_require__.f.consumes = (chunkId, promises) => {
  // ... 将 moduleMap 中的加载函数与 chunk 关联
};

// 初始化：将模块映射表注册到全局容器中
__webpack_require__.o(__webpack_require__.S, 'app_remote') || __webpack_require__.S['app_remote'] = moduleMap;
```
被暴露的模块打包成独立的chunk模块，webpack为chunk创建一个模块容器的包装层，容器负责：
1. 管理模块初始化
2. 处理与host应用的共享依赖
输出结果：
app_remote.js：remote应用自身的主包
src_Button_js.js:被暴露的组件的代码块
remoteEntry.js:最重要的文件，包含了模块映射表和初始化逻辑

2、host应用的构建过程
host消费remote的模块
```
// webpack.config.js of Host
new ModuleFederationPlugin({
  name: 'app_host',
  remotes: {
    // 关键：声明远程模块的地址和全局名称
    'app_remote': 'app_remote@http://cdn.com/remote/remoteEntry.js'
  },
  shared: ['react', 'react-dom']
})
```
当 Host 应用的代码中出现 import(‘app_remote/Button’)时，Webpack 不会将 Button的代码打包进来，也不会去构建 Remote 应用。相反，它会生成一个轻量的代理模块/占位模块。
这个代理模块只包含一些元数据和一个指向远程模块的加载逻辑。它的作用是在运行时“拦截”这个导入请求，并将其重定向到真正的 Remote 应用。

Webpack 会正常分析 Host 应用的其他依赖并打包，但对于标记为 remote的导入，它会跳过依赖分析，只保留一个“接口”
###### 运行时：
运行时阶段是魔法发生的地方，所有在构建时准备的结构都在这里协同工作。其核心是 Webpack 增强后的 Runtime代码
1、初始化阶段
host应用启动：
  host的index.html加载host应用的脚本(app_host.js)
  host的webpack runtime运行时，初始化自己的模块系统
  host的runtime运行时，根据配置，预加载或注册远程模块的入口，创建一个全局的模块容器来管理远程模块
注册共享依赖：
  host应用启动时，会将自己的shared依赖的版本信息注册到一个全局的共享作用域中，这个作用域是所有模块联邦应用共用的
动态加载远程模块：
  当host的代码执行到import(app_remote/Button)时，